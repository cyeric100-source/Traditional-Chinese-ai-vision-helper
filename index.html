<!-- START OF FILE 60ai_studio_code_v2.html -->

<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 視障助理 (極簡全能版 - 2025 OCR 強化版)</title>
    
    <!-- 引入 Marked.js 解析 Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.2/lib/marked.umd.min.js"></script>
    
    <!-- 引入 DOMPurify 進行 HTML 消毒 (安全性修正) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>

    <!-- 引入 Tesseract.js (OCR 引擎 v5) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <!-- 
        引入最新版 PDF.js (v4.10.38) 
        使用 ES Module 方式引入，並掛載到 window 以供全域使用
    -->
    <script type="module">
        import * as pdfjsLib from 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.mjs';
        
        // 設定 Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.mjs';
        
        // 將 pdfjsLib 掛載到全域變數
        window.pdfjsLib = pdfjsLib;
        
        console.log("PDF.js v4.10.38 Loaded successfully via ES Module.");
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;      /* 黃色高亮 */
            --user-header-color: #0088ff; /* 用戶標題色 */
            --ai-header-color: #FFFF00;   /* AI 標題色 */
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;            /* 狀態列背景 */
            --danger-color: #ff4444;      /* 危險操作色 */
            --info-color: #008800;        /* 資訊色 */
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.2rem; line-height: 1.6;
            padding-top: 60px; /* 預留頂部狀態列空間 */
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 10px 10px 450px 10px;
        }

        .app-title { 
            font-size: 1.5rem; text-align: center; margin: 10px 0; color: #ccc; font-weight: bold;
        }
        
        details h2 { 
            font-size: 1.4rem; color: #ccc; 
            border-bottom: 2px solid #333; padding-bottom: 5px; margin-top: 10px; 
            display: inline-block;
        }

        input, select, textarea {
            width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px;
            background: var(--input-bg); border: 2px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px; box-sizing: border-box;
        }

        #system-prompt {
            min-height: 300px;
            resize: vertical;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.4;
        }
        
        *:focus-visible { outline: 4px solid var(--accent-color) !important; }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            border: 2px solid #fff; padding: 12px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-top: 5px; cursor: pointer; touch-action: manipulation;
        }
        button:disabled { filter: grayscale(100%); opacity: 0.7; cursor: not-allowed; }
        button.secondary { background-color: #333; color: #fff; border-color: #777; }
        
        button.mini-copy-btn {
            background-color: #333; color: #fff; border: 1px solid #777;
            padding: 6px 12px; font-size: 0.9rem; margin-top: 10px;
            width: auto; display: inline-block;
        }
        button.mini-copy-btn:hover { background-color: #555; }
        
        button.danger {
            background-color: #550000;
            color: #ffcccc;
            border-color: #ff4444;
        }
        
        button.info-btn {
            background-color: #004400;
            color: #ccffcc;
            border-color: #00ff00;
        }

        button.recording {
            background-color: #ff0000 !important;
            color: #ffffff !important;
            animation: pulse 1.5s infinite;
        }
        button.processing {
            background-color: #ff8800 !important;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        @media (prefers-reduced-motion: reduce) {
            button.recording, button.processing {
                animation: none !important;
                box-shadow: 0 0 0 4px rgba(255, 0, 0, 0.5);
            }
            * { transition: none !important; }
        }

        details { border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-bottom: 10px; background: #111; }
        summary { cursor: pointer; padding: 5px; }
        
        .message-area { min-height: 100px; padding-bottom: 20px; }
        
        .message {
            background: #111; padding: 15px; margin-bottom: 25px;
            border-left: 5px solid var(--border-color);
            overflow-wrap: break-word; word-wrap: break-word; word-break: break-word;
        }
        .message:focus { outline: none; border-left: 8px solid var(--accent-color); background: #222; }

        .message h1.msg-heading {
            font-size: 1.4rem; margin: 0 0 10px 0; padding-bottom: 5px;
            border-bottom: 1px dashed #444; line-height: 1.3;
        }

        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.user h1.msg-heading { color: var(--user-header-color); }
        
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message.assistant h1.msg-heading { color: var(--ai-header-color); }

        .message.error { border-left-color: #ff0000; background: #330000; }
        .message.error h1.msg-heading { color: #ff5555; }

        .markdown-body { line-height: 1.7; overflow-wrap: break-word; }
        .markdown-body h1, .markdown-body h2 { color: #88CCFF; border-bottom: none; margin-top: 1.5em; }
        .markdown-body p { margin-bottom: 10px; white-space: pre-wrap; }
        .markdown-body pre { 
            background: #222; padding: 10px; 
            overflow-x: auto; border: 1px solid #444; 
            white-space: pre; 
        }
        .markdown-body code { background: #333; padding: 2px 4px; word-break: break-all; }

        .controls-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #000; border-top: 3px solid var(--accent-color);
            padding: 10px; z-index: 100;
        }

        .row { display: flex; gap: 10px; margin-bottom: 8px; align-items: flex-end; }
        
        .check-btn {
            display: flex; align-items: center; justify-content: center;
            background: #222; border: 1px solid #555; color: #fff;
            padding: 10px; border-radius: 6px; flex: 1;
            cursor: pointer;
            margin-top: 5px;
            height: auto; 
            min-height: 52px;
        }
        .check-btn input { width: 20px; height: 20px; margin: 0 8px 0 0; }

        #user-input {
            margin: 0;
            min-height: 80px; max-height: 200px;
            resize: vertical; overflow-y: auto;
            flex: 1; transition: border-color 0.2s;
        }
        #user-input.dragover { border-color: var(--accent-color) !important; background-color: #222; }

        #status-bar {
            position: fixed; top: 0; left: 0; right: 0;
            background: var(--status-bg); color: #fff;
            padding: 10px; text-align: center;
            font-weight: bold; font-size: 1.1rem;
            z-index: 2000; border-bottom: 2px solid var(--border-color);
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; border-bottom-color: #00ff00; }
        #status-bar.busy { background: #664400; border-bottom-color: #ffff00; }
        #status-bar.error { background: #660000; border-bottom-color: #ff0000; }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        #custom-model-wrapper { margin-top: -5px; margin-bottom: 10px; }
        
        .settings-subsection {
            border: 1px solid #444; padding: 10px; border-radius: 6px; margin: 10px 0; background: #222;
        }
        .settings-subsection h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent-color); }

        .export-actions { margin-bottom: 20px; display: flex; gap: 10px; }
        .export-actions button { margin-top: 0; font-size: 1rem; padding: 8px; }
    </style>
</head>
<body>

<!-- 頂部狀態列 -->
<div id="status-bar" role="status" aria-live="assertive" aria-atomic="true">系統初始化中...</div>

<div class="container">
    <h1 class="app-title">AI 視障助理 (極簡全能版 - 2025 OCR 強化版)</h1>

    <!-- 設定區 -->
    <details id="settings-area">
        <summary role="button" aria-expanded="false" id="settings-summary" aria-keyshortcuts="Alt+Shift+S">
            <h2>設定 (Alt+Shift+S)</h2>
        </summary>
        
        <div style="margin-top: 15px;">
            <label for="provider-select">主要 AI 服務商:</label>
            <select id="provider-select" onchange="handleProviderChange()">
                <option value="gemini">Google Gemini (推薦)</option>
                <option value="openrouter">OpenRouter (多模型)</option>
                <option value="mistral">Mistral AI</option>
                <option value="openai">OpenAI (GPT)</option>
                <option value="groq">Groq</option>
                <option value="perplexity">Perplexity</option>
            </select>

            <label for="api-key">主要 API Key:</label>
            <input type="password" id="api-key" placeholder="在此貼上您的 API Key" autocomplete="off">
            
            <label for="model-filter-input">篩選模型 (即時搜尋):</label>
            <input type="text" id="model-filter-input" placeholder="輸入關鍵字篩選 (如: gemini, latest)..." oninput="handleModelFilter()">

            <label for="model-select">模型選擇 (2025最新):</label>
            <div class="row" style="margin-bottom: 10px;">
                <select id="model-select" style="margin-bottom:0;" onchange="handleModelSelectChange()"></select>
                <button type="button" id="refresh-btn" class="secondary" style="width: auto; margin-top:0;" onclick="fetchOnlineModels()" title="從網路更新模型清單">更新模型清單</button>
            </div>
            
            <div id="custom-model-wrapper" class="hidden">
                <input type="text" id="custom-model-input" placeholder="手動輸入模型 ID" onchange="handleCustomInputChange()">
            </div>

            <div id="openrouter-settings" class="hidden settings-subsection">
                <h3>OpenRouter 搜尋設定</h3>
                <label class="check-btn">
                    <input type="checkbox" id="openrouter-web-search">
                    <span>啟用聯網搜尋 (Web Search) - <small>可能需額外付費</small></span>
                </label>
            </div>
            
            <label class="check-btn" style="flex:none; width:auto; margin-bottom: 10px;">
                <input type="checkbox" id="enter-to-send" checked>
                <span>按 Enter 鍵傳送 (取消勾選則 Enter 為換行)</span>
            </label>

            <div class="settings-subsection">
                <h3>語音輸入設定</h3>
                <label for="voice-engine">語音辨識引擎:</label>
                <select id="voice-engine" onchange="saveVoiceSettings()">
                    <option value="browser">瀏覽器原生 (免費，品質普通)</option>
                    <option value="openai">OpenAI Whisper (高準確，需付費)</option>
                    <option value="groq">Groq Whisper (極速，需 Key)</option>
                </select>
                
                <label for="voice-api-key">語音辨識專用 API Key (選填):</label>
                <input type="password" id="voice-api-key" placeholder="若留空，將嘗試使用主要 API Key" autocomplete="off" onchange="saveVoiceSettings()">
                <small style="color:#aaa; display:block; margin-bottom:5px;">* 若使用 Gemini 聊天但想用 Whisper 語音，請在此填入 OpenAI/Groq Key。</small>
            </div>

            <label for="timeout-setting">回應逾時 (秒):</label>
            <input type="number" id="timeout-setting" value="120" min="5" step="5">

            <label for="system-prompt">角色指令 (支援大量文字):</label>
            <textarea id="system-prompt" placeholder="在此輸入系統指令..."></textarea>

            <div class="row">
                <button type="button" onclick="saveSettings()">儲存設定</button>
                <button type="button" onclick="restoreDefaults()" class="secondary">恢復預設值</button>
                <button type="button" onclick="showHelp()" class="secondary" style="background:#004488; color:white;">功能說明</button>
            </div>
        </div>
    </details>

    <!-- 結果區 -->
    <main role="main">
        <div id="chat-output" class="message-area"></div>
        
        <div class="export-actions">
            <button type="button" id="copy-btn" class="secondary hidden" onclick="copyResult()" aria-keyshortcuts="Alt+Shift+C" style="flex:1;">
                複製所有對話內容 (Alt+Shift+C)
            </button>
            <button type="button" id="export-txt-btn" class="secondary hidden" onclick="exportChat('txt')" aria-keyshortcuts="Alt+Shift+T" style="flex:1;">
                匯出對話為 TXT (Alt+Shift+T)
            </button>
            <button type="button" id="export-html-btn" class="secondary hidden" onclick="exportChat('html')" aria-keyshortcuts="Alt+Shift+H" style="flex:1;">
                匯出對話為 HTML (Alt+Shift+H)
            </button>
        </div>
    </main>
</div>

<!-- 控制區 -->
<footer class="controls-wrapper" role="region" aria-label="操作區">
    <form onsubmit="handleSubmit(event)">
        <!-- 第一排：功能按鈕 -->
        <div class="row">
            <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
            <!-- 專用 PDF 完整讀取輸入 -->
            <input type="file" id="pdf-full-input" class="visually-hidden" accept="application/pdf" onchange="handlePdfFullRead(event)">
            
            <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()" aria-keyshortcuts="Alt+Shift+U" style="flex:1;">
                選擇檔案 (Alt+Shift+U)
            </button>
            
            <button type="button" id="pdf-full-btn" class="info-btn" onclick="document.getElementById('pdf-full-input').click()" aria-keyshortcuts="Alt+Shift+F" style="flex:1;" title="PDF 完整顯示 (不經 AI)">
                PDF 完整閱讀 (Alt+Shift+F)
            </button>
            
            <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()" aria-keyshortcuts="Alt+Shift+N" style="flex:1;">
                清除對話 (Alt+Shift+N)
            </button>

            <label class="check-btn" style="flex:1;">
                <input type="checkbox" id="pause-send" aria-keyshortcuts="Alt+Shift+P">
                <span>暫停傳送 (Alt+Shift+P)</span>
            </label>
        </div>
        
        <!-- 第二排：輸入與發送 -->
        <div class="row">
            <button type="button" id="voice-btn" class="secondary" onclick="toggleVoiceInput()" aria-keyshortcuts="Alt+Shift+V" style="width: auto; padding: 0 15px; height: 80px; margin:0; font-size: 1.2rem;" title="語音輸入 (Alt+Shift+V)" aria-label="語音輸入 (Alt+Shift+V)">語音輸入</button>
            
            <textarea id="user-input" placeholder="輸入訊息... (可拖放檔案或 Ctrl+V)" aria-keyshortcuts="Alt+Shift+I" autocomplete="off" rows="3" aria-label="輸入訊息區"></textarea>
            
            <button type="submit" id="submit-btn" aria-keyshortcuts="Alt+Shift+K" style="width: 80px; height: 80px; margin:0;" title="發送 (Alt+Shift+K)">傳送</button>
        </div>
    </form>
</footer>

<script>
    window.onerror = function(message, source, lineno, colno, error) {
        const statusBar = document.getElementById('status-bar');
        if (statusBar) {
            statusBar.innerText = `發生錯誤: ${message}`;
            statusBar.className = 'error';
        }
        console.error("Global Error:", message, error);
    };

    const DEFAULT_PROMPT = `# 角色設定 (Persona)
你是一位專為香港視障人士服務的頂尖 AI 視覺與資訊助理。你的核心職責是成為用戶的眼睛與大腦延伸，提供安全、精準且易於透過螢幕朗讀軟體 (Screen Reader) 接收的資訊。

# 全域規則 (Global Rules)
无论处理何种任务，你必须严格遵守以下三大原则：

1.  **語言規範**：
    *   **唯一輸出語言**：繁體中文（香港慣用詞彙）。
    *   **翻譯要求**：若原始資料為外語，必須消化後翻譯為流暢中文，**嚴格禁止**在輸出中顯示原文（除非用戶特別要求對照）。

2.  **無障礙格式 (Accessibility Format)**：
    *   **Markdown 結構**：必須善用 \`#\` (標題)、\`-\` (清單) 來建立清晰的階層，方便讀屏軟體導航。
    *   **符號禁令**：**嚴格禁止**輸出 \`[ ]\` (中括號) 或 \`{ }\` (大括號) 以及任何可能干擾朗讀節奏的裝飾性符號。

3.  **內容風格**：
    *   在資訊豐富的前提下，文字必須精簡洗鍊 (Concise)，避免冗言贅字。重點必須置於最前方。`;

    const PROMPT_VERSION_KEY = "prompt_version_2025_fixed_v7_ocr_enhanced";

    const PROVIDERS = {
        gemini: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "gemini-1.5-flash", 
            canFetch: true,
            models: ["gemini-1.5-flash", "gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-2.0-pro-exp"],
            listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}"
        },
        openrouter: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "openai/gpt-4o",
            canFetch: true,
            models: ["openai/gpt-4o", "anthropic/claude-3.5-sonnet", "google/gemini-pro-1.5", "meta-llama/llama-3.1-405b"],
            listUrl: "https://openrouter.ai/api/v1/models"
        },
        mistral: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "mistral-large-latest",
            canFetch: true,
            models: ["mistral-large-latest", "pixtral-large-latest", "ministral-8b-latest"],
            listUrl: "https://api.mistral.ai/v1/models"
        },
        openai: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "gpt-4o",
            canFetch: true, 
            models: ["gpt-4o", "gpt-4o-mini", "o1-preview"],
            listUrl: "https://api.openai.com/v1/models"
        },
        groq: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "llama-3.3-70b-versatile", 
            canFetch: true, 
            models: ["llama-3.3-70b-versatile", "llama-3.1-8b-instant", "llama-3.2-90b-vision-preview"], 
            listUrl: "https://api.groq.com/openai/v1/models"
        },
        perplexity: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "sonar-pro",
            canFetch: false,
            models: ["sonar-pro", "sonar", "sonar-reasoning-pro"]
        }
    };

    let currentActiveModelId = "";
    let selectedFile = null;
    let recognition = null; 
    let mediaRecorder = null;
    let audioChunks = [];
    let chatHistory = [];
    let audioContext = null;
    let allCurrentModels = [];
    
    // PDF.js worker reference handled by module import, but needed for some internal logic
    const pdfCMapUrl = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/cmaps/';

    function unlockAudioContext() {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                document.removeEventListener('click', unlockAudioContext);
                document.removeEventListener('touchstart', unlockAudioContext);
            });
        }
    }
    document.addEventListener('click', unlockAudioContext);
    document.addEventListener('touchstart', unlockAudioContext);
    
    document.addEventListener('keydown', handleGlobalShortcuts);

    function handleGlobalShortcuts(e) {
        if (!e.altKey || !e.shiftKey) return;
        const key = e.key.toLowerCase();
        
        const actions = {
            's': { id: 'settings-summary', type: 'click' },
            'c': { id: 'copy-btn', type: 'click' },
            't': { id: 'export-txt-btn', type: 'click' },
            'h': { id: 'export-html-btn', type: 'click' },
            'u': { id: 'upload-btn', type: 'click' },
            'f': { id: 'pdf-full-btn', type: 'click' },
            'n': { id: 'new-chat-btn', type: 'click' },
            'p': { id: 'pause-send', type: 'click' },
            'v': { id: 'voice-btn', type: 'click' },
            'k': { id: 'submit-btn', type: 'click' },
            'i': { id: 'user-input', type: 'focus' },
            'r': { selector: '.latest-copy-btn', type: 'click' }
        };

        if (actions[key]) {
            e.preventDefault();
            let target;
            if (actions[key].id) target = document.getElementById(actions[key].id);
            else if (actions[key].selector) target = document.querySelector(actions[key].selector);

            if (target) {
                if (actions[key].type === 'click') target.click();
                else if (actions[key].type === 'focus') target.focus();
            }
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        try {
            if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => {
                    localStorage.removeItem(`${p}_prompt`);
                });
                localStorage.setItem(PROMPT_VERSION_KEY, 'true');
            }

            const savedProvider = localStorage.getItem('provider');
            const settingsDetails = document.getElementById('settings-area');
            
            const savedTimeout = localStorage.getItem('timeout_setting');
            if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;

            const savedWebSearch = localStorage.getItem('openrouter_web_search');
            document.getElementById('openrouter-web-search').checked = (savedWebSearch === 'true');

            const savedVoiceEngine = localStorage.getItem('voice_engine');
            if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
            const savedVoiceKey = localStorage.getItem('voice_api_key');
            if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;

            const savedEnter = localStorage.getItem('enter_to_send');
            if (savedEnter === null || savedEnter === 'true') {
                document.getElementById('enter-to-send').checked = true;
            } else {
                document.getElementById('enter-to-send').checked = false;
            }

            if (savedProvider && PROVIDERS[savedProvider]) {
                document.getElementById('provider-select').value = savedProvider;
                settingsDetails.open = false; 
            } else {
                document.getElementById('provider-select').value = 'gemini'; 
                settingsDetails.open = true; 
            }
            
            handleProviderChange(false); 
            initVoiceSystem();
            initPasteImage();
            initDragAndDrop();
            initEnterKey();

        } catch (e) {
            console.error("Init Error", e);
            updateStatusBar("初始化錯誤: " + e.message, "error");
        } finally {
            setTimeout(showReadyStatus, 500);
        }
    });

    function playAudioCue(type) {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        const now = audioContext.currentTime;
        
        if (type === 'start') {
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(660, now);
            gainNode.gain.setValueAtTime(0.1, now);
            oscillator.start(now);
            oscillator.stop(now + 0.1);
        } else if (type === 'success') {
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, now);
            oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15);
            gainNode.gain.setValueAtTime(0.1, now);
            oscillator.start(now);
            oscillator.stop(now + 0.2);
        } else if (type === 'error') {
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, now);
            gainNode.gain.setValueAtTime(0.15, now);
            oscillator.start(now);
            oscillator.stop(now + 0.4);
        }
    }

    function resetConversation() {
        chatHistory = []; 
        document.getElementById('chat-output').innerHTML = ""; 
        document.getElementById('user-input').value = "";
        selectedFile = null;
        document.getElementById('upload-btn').innerText = "選擇檔案 (Alt+Shift+U)";
        document.getElementById('file-input').value = "";
        toggleExportButtons(false);
        showTransientStatus("對話紀錄已清除 (新對話)", "info");
    }

    function initVoiceSystem() {
        const engine = document.getElementById('voice-engine').value;
        if (engine === 'browser') {
            initBrowserSpeech();
        } else {
            if (recognition) {
                recognition.stop();
                recognition = null;
            }
        }
    }

    function initBrowserSpeech() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-HK'; 
            recognition.continuous = false; 
            recognition.interimResults = true; 

            recognition.onstart = function() {
                const btn = document.getElementById('voice-btn');
                btn.classList.add('recording');
                showTransientStatus('正在聆聽 (瀏覽器)...', 'info');
                playAudioCue('start');
            };

            recognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
                    else interimTranscript += event.results[i][0].transcript;
                }
                const input = document.getElementById('user-input');
                if (finalTranscript) {
                     const currentVal = input.value;
                     input.value = currentVal ? currentVal + " " + finalTranscript : finalTranscript;
                }
            };

            recognition.onerror = function(event) {
                showTransientStatus('語音辨識錯誤: ' + event.error, 'error');
                playAudioCue('error');
                stopVoiceInput();
            };
            recognition.onend = function() {
                stopVoiceInput();
            };
        }
    }

    async function toggleVoiceInput() {
        const engine = document.getElementById('voice-engine').value;
        const btn = document.getElementById('voice-btn');

        if (btn.classList.contains('recording')) {
            if (engine === 'browser' && recognition) {
                recognition.stop();
            } else {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    btn.classList.remove('recording');
                    btn.classList.add('processing');
                    showTransientStatus('正在上傳並辨識...', 'busy');
                }
            }
            return;
        }

        if (engine === 'browser') {
            if (recognition) recognition.start();
            else showTransientStatus('此瀏覽器不支援原生語音', 'error');
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mimeTypes = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/aac'];
                let selectedMime = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));
                const options = selectedMime ? { mimeType: selectedMime } : undefined;
                
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.detectedMimeType = selectedMime || '';
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = async () => {
                    const type = mediaRecorder.detectedMimeType || 'audio/webm';
                    const audioBlob = new Blob(audioChunks, { type: type }); 
                    await processWhisperAudio(audioBlob, engine, type);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                btn.classList.add('recording');
                showTransientStatus('正在錄音 (Whisper)...', 'info');
                playAudioCue('start');
            } catch (err) {
                showTransientStatus('無法存取麥克風: ' + err.message, 'error');
                playAudioCue('error');
            }
        }
    }

    async function processWhisperAudio(blob, engine, mimeType) {
        const btn = document.getElementById('voice-btn');
        let apiKey = document.getElementById('voice-api-key').value.trim();
        if (!apiKey) apiKey = document.getElementById('api-key').value.trim();

        if (!apiKey) {
            alert("使用 Whisper 語音需要 API Key (OpenAI 或 Groq)。");
            btn.classList.remove('processing');
            showReadyStatus();
            return;
        }

        const formData = new FormData();
        let ext = 'webm';
        if (mimeType && mimeType.includes('mp4')) ext = 'mp4';
        else if (mimeType && mimeType.includes('aac')) ext = 'aac';

        formData.append('file', blob, `recording.${ext}`);
        
        let url = "";
        let modelName = "";

        if (engine === 'openai') {
            url = "https://api.openai.com/v1/audio/transcriptions";
            modelName = "whisper-1";
        } else if (engine === 'groq') {
            url = "https://api.groq.com/openai/v1/audio/transcriptions";
            modelName = "whisper-large-v3"; 
        }

        formData.append('model', modelName);

        try {
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${apiKey}` },
                body: formData
            });
            if (!res.ok) throw new Error(await res.text());
            const data = await res.json();
            if (data.text) {
                const input = document.getElementById('user-input');
                input.value = input.value ? input.value + " " + data.text : data.text;
                showTransientStatus("辨識完成");
            }
        } catch (e) {
            showTransientStatus("Whisper 錯誤: " + e.message, 'error');
            playAudioCue('error');
        } finally {
            btn.classList.remove('processing');
            showReadyStatus();
        }
    }

    function stopVoiceInput() {
        const btn = document.getElementById('voice-btn');
        btn.classList.remove('recording');
        btn.classList.remove('processing');
        const bar = document.getElementById('status-bar');
        if (bar.innerText.includes('聆聽') || bar.innerText.includes('錄音')) showReadyStatus();
    }

    function saveVoiceSettings() {
        const engine = document.getElementById('voice-engine').value;
        const key = document.getElementById('voice-api-key').value;
        localStorage.setItem('voice_engine', engine);
        localStorage.setItem('voice_api_key', key);
        initVoiceSystem();
    }

    function initPasteImage() {
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                    const blob = items[i].getAsFile();
                    handleFileSelect(blob);
                    e.preventDefault(); 
                    return;
                }
            }
        });
    }

    function initDragAndDrop() {
        const dropZone = document.getElementById('user-input');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        dropZone.addEventListener('dragover', () => dropZone.classList.add('dragover'));
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFileSelect(e.dataTransfer.files[0]);
        });
    }

    function initEnterKey() {
        document.getElementById('user-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !e.isComposing) {
                if (document.getElementById('enter-to-send').checked) {
                    e.preventDefault();
                    document.getElementById('submit-btn').click();
                }
            }
        });
    }

    function updateStatusBar(text, state = 'ready') {
        const bar = document.getElementById('status-bar');
        bar.innerText = text;
        bar.className = '';
        if (state === 'ready') bar.classList.add('ready');
        else if (state === 'busy') bar.classList.add('busy');
        else if (state === 'error') bar.classList.add('error');
    }

    function showReadyStatus() {
        updateStatusBar("準備就緒", 'ready');
    }

    function showTransientStatus(msg, type = 'success') {
        updateStatusBar(msg, type === 'error' ? 'error' : 'ready');
        if (['success', 'error', 'info'].includes(type)) {
            setTimeout(() => {
                const bar = document.getElementById('status-bar');
                if (!bar.classList.contains('busy') && !document.getElementById('voice-btn').classList.contains('recording')) {
                    showReadyStatus();
                }
            }, 3000);
        }
    }

    function addMessage(role, content) {
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.tabIndex = -1; 

        const header = document.createElement('h1');
        header.className = 'msg-heading';
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-body';

        if (role === 'user') {
            header.innerText = '輸入問題：';
            contentDiv.innerText = content;
        } else if (role === 'assistant') {
            header.innerText = '回應結果：';
            contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(content));
            document.getElementById('copy-btn').classList.remove('hidden');
            toggleExportButtons(true);
            
            const miniCopyBtn = document.createElement('button');
            miniCopyBtn.className = 'mini-copy-btn latest-copy-btn';
            document.querySelectorAll('.latest-copy-btn').forEach(b => { if(b !== miniCopyBtn) b.classList.remove('latest-copy-btn'); });
            
            miniCopyBtn.innerText = '複製此回應 (Alt+Shift+R)';
            miniCopyBtn.ariaLabel = '複製此回應 (Alt+Shift+R)';
            miniCopyBtn.onclick = function() {
                navigator.clipboard.writeText(contentDiv.innerText).then(() => showTransientStatus("已複製該回應"));
            };
            div.appendChild(miniCopyBtn);
        } else {
            header.innerText = (role === 'error') ? '發生錯誤：' : '系統訊息：';
            contentDiv.innerText = content;
        }

        div.appendChild(header);
        div.appendChild(contentDiv);
        document.getElementById('chat-output').appendChild(div);
        return div; 
    }

    function toggleExportButtons(show) {
        ['copy-btn', 'export-txt-btn', 'export-html-btn'].forEach(id => {
            const el = document.getElementById(id);
            if(show) el.classList.remove('hidden'); else el.classList.add('hidden');
        });
    }

    function handleProviderChange(save = true) {
        const pKey = document.getElementById('provider-select').value;
        const conf = PROVIDERS[pKey];
        if (!conf) return;

        document.getElementById('api-key').value = localStorage.getItem(`${pKey}_key`) || "";
        document.getElementById('system-prompt').value = localStorage.getItem(`${pKey}_prompt`) || conf.prompt;
        
        if (pKey === 'openrouter') document.getElementById('openrouter-settings').classList.remove('hidden');
        else document.getElementById('openrouter-settings').classList.add('hidden');
        
        const cachedListStr = localStorage.getItem(`${pKey}_model_list`);
        let modelList = conf.models;
        if (cachedListStr) {
            try {
                const parsedList = JSON.parse(cachedListStr);
                if (Array.isArray(parsedList) && parsedList.length > 0) modelList = parsedList;
            } catch (e) { console.error(e); }
        }
        allCurrentModels = modelList;
        document.getElementById('model-filter-input').value = "";
        
        const savedModel = localStorage.getItem(`${pKey}_model`) || conf.defaultModel;
        currentActiveModelId = savedModel;
        
        handleModelFilter();
        document.getElementById('refresh-btn').style.display = conf.canFetch ? 'block' : 'none';
        resetConversation();
        
        if (save) localStorage.setItem('provider', pKey);
        showReadyStatus();
    }

    function handleModelFilter() {
        const filterText = document.getElementById('model-filter-input').value.toLowerCase();
        const filteredList = allCurrentModels.filter(m => m.toLowerCase().includes(filterText));
        updateModelSelect(filteredList, currentActiveModelId);
    }

    function updateModelSelect(models, targetModel) {
        const select = document.getElementById('model-select');
        select.innerHTML = "";
        let found = false;
        models.forEach(m => {
            let opt = document.createElement('option');
            opt.value = m; opt.innerText = m;
            if (m === targetModel) found = true;
            select.appendChild(opt);
        });
        
        let customOpt = document.createElement('option');
        customOpt.value = "CUSTOM_ENTRY"; customOpt.innerText = "自行輸入模型 ID...";
        select.appendChild(customOpt);

        const customWrapper = document.getElementById('custom-model-wrapper');
        const customInput = document.getElementById('custom-model-input');

        if (found) {
            select.value = targetModel; 
            customWrapper.classList.add('hidden');
        } else {
            select.value = "CUSTOM_ENTRY"; 
            customWrapper.classList.remove('hidden'); 
            customInput.value = targetModel;
        }
    }

    async function fetchOnlineModels() {
        const pKey = document.getElementById('provider-select').value;
        let apiKey = document.getElementById('api-key').value.trim();
        const conf = PROVIDERS[pKey];
        if (!conf.canFetch) return;
        
        if (!apiKey && ['gemini', 'groq', 'openai', 'mistral'].includes(pKey)) {
            alert("請先輸入 API Key 才能更新清單");
            return;
        }

        const btn = document.getElementById('refresh-btn');
        const originalText = btn.innerText;
        btn.innerText = "讀取中...";
        btn.disabled = true;

        try {
            let newModels = [];
            let res, data;

            if (pKey === 'openrouter') {
                res = await fetch("https://openrouter.ai/api/v1/models");
                data = await res.json();
                if (data.data) newModels = data.data.sort((a,b)=> (b.created||0)-(a.created||0)).map(m=>m.id);
            } 
            else if (pKey === 'groq') {
                res = await fetch(conf.listUrl, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                data = await res.json();
                if (data.data) newModels = data.data.map(m=>m.id);
            }
            else if (pKey === 'mistral') {
                res = await fetch(conf.listUrl, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                data = await res.json();
                if (data.data) newModels = data.data.map(m=>m.id);
            }
            else if (pKey === 'gemini') {
                res = await fetch(conf.listUrl.replace('{KEY}', apiKey));
                if (!res.ok) throw new Error(await res.text());
                data = await res.json();
                if (data.models) {
                    newModels = data.models
                        .filter(m => m.supportedGenerationMethods?.includes("generateContent") && !m.name.includes("embedding"))
                        .sort((a,b)=> b.name.localeCompare(a.name))
                        .map(m => m.name.replace("models/", ""));
                }
            }
            else if (pKey === 'openai') {
                res = await fetch(conf.listUrl, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                data = await res.json();
                if (data.data) newModels = data.data.filter(m=>m.id.startsWith('gpt')).map(m=>m.id);
            }

            if (newModels.length > 0) {
                localStorage.setItem(`${pKey}_model_list`, JSON.stringify(newModels));
                allCurrentModels = newModels;
                handleModelFilter();
                currentActiveModelId = newModels[0]; 
                resetConversation();
                showTransientStatus(`已更新清單，找到 ${newModels.length} 個模型。`);
                playAudioCue('success');
            } else {
                showTransientStatus("未找到合適模型", "error");
            }
        } catch (e) {
            showTransientStatus(`更新失敗: ${e.message}`, "error");
            playAudioCue('error');
        } finally {
            btn.innerText = originalText;
            btn.disabled = false;
        }
    }

    function handleModelSelectChange() {
        const select = document.getElementById('model-select');
        if (select.value === "CUSTOM_ENTRY") {
            document.getElementById('custom-model-wrapper').classList.remove('hidden');
            document.getElementById('custom-model-input').focus();
        } else {
            document.getElementById('custom-model-wrapper').classList.add('hidden');
            currentActiveModelId = select.value;
        }
        resetConversation();
        showReadyStatus(); 
    }

    function handleCustomInputChange() {
        currentActiveModelId = document.getElementById('custom-model-input').value.trim();
        resetConversation();
        showReadyStatus();
    }

    function saveSettings() {
        const pKey = document.getElementById('provider-select').value;
        currentActiveModelId = (document.getElementById('model-select').value === "CUSTOM_ENTRY") ?
             document.getElementById('custom-model-input').value.trim() : document.getElementById('model-select').value;

        localStorage.setItem(`${pKey}_key`, document.getElementById('api-key').value.trim());
        localStorage.setItem(`${pKey}_model`, currentActiveModelId);
        localStorage.setItem(`${pKey}_prompt`, document.getElementById('system-prompt').value);
        localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
        localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
        localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
        saveVoiceSettings();
        
        showTransientStatus(`設定已儲存: ${pKey}`); 
        playAudioCue('success');
        document.getElementById('settings-area').open = false;
    }

    function restoreDefaults() {
        const pKey = document.getElementById('provider-select').value;
        document.getElementById('system-prompt').value = PROVIDERS[pKey].prompt;
        document.getElementById('timeout-setting').value = 120;
        localStorage.removeItem(`${pKey}_model`);
        localStorage.removeItem(`${pKey}_prompt`);
        handleProviderChange(true);
        showTransientStatus("已恢復預設");
    }

    function showHelp() {
        alert("快速鍵:\nAlt+Shift+S: 設定\nAlt+Shift+U: 上傳\nAlt+Shift+F: PDF 完整閱讀\nAlt+Shift+N: 新對話\nAlt+Shift+K: 傳送\nAlt+Shift+V: 語音\nAlt+Shift+P: 暫停傳送\nAlt+Shift+R: 複製回應");
    }

    function copyResult() {
        navigator.clipboard.writeText(document.getElementById('chat-output').innerText)
            .then(() => showTransientStatus("已複製全部歷史紀錄"));
    }

    function exportChat(format) {
        const output = document.getElementById('chat-output');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        let content = "", mimeType = "", extension = "";

        if (format === 'html') {
            const css = document.querySelector('style').innerHTML;
            content = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>對話紀錄</title><style>${css} body { padding: 20px; }</style></head><body><div class="container">${output.innerHTML}</div></body></html>`;
            mimeType = "text/html"; extension = "html";
        } else {
            content = output.innerText;
            mimeType = "text/plain"; extension = "txt";
        }

        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `chat-export-${timestamp}.${extension}`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showTransientStatus(`已匯出 ${extension.toUpperCase()}`);
    }

    function handleFileSelect(fileObj) {
        try {
            if (fileObj) selectedFile = fileObj;
            else {
                const fileInput = document.getElementById('file-input');
                if (fileInput.files.length > 0) selectedFile = fileInput.files[0];
            }

            if (selectedFile) {
                if (selectedFile.size === 0) throw new Error("檔案大小為 0。");
                document.getElementById('upload-btn').innerText = `已選取: ${selectedFile.name}`;
                document.getElementById('user-input').setAttribute('aria-label', `已附加檔案：${selectedFile.name}`);
                showTransientStatus(`已加入檔案`);
                playAudioCue('success');
                if (!document.getElementById('pause-send').checked) setTimeout(() => document.querySelector('footer form').requestSubmit(), 500);
            }
        } catch (e) {
            showTransientStatus("檔案讀取錯誤: " + e.message, "error");
            playAudioCue('error');
        }
    }

    // --- PDF OCR 核心改進區塊 (2025 Revised) ---

    // 大津演算法 (Otsu's Method) 計算最佳閾值
    function getOtsuThreshold(imageData) {
        const histogram = new Array(256).fill(0);
        const data = imageData.data;
        let totalPixels = 0;

        // 1. 建立直方圖 (僅取綠色通道作為亮度參考，因已灰階化，RGB相同)
        for (let i = 0; i < data.length; i += 4) {
            histogram[data[i]]++;
            totalPixels++;
        }

        let sum = 0;
        for (let i = 0; i < 256; i++) sum += i * histogram[i];

        let sumB = 0;
        let wB = 0;
        let wF = 0;
        let maxVar = 0;
        let threshold = 0;

        // 2. 遍歷尋找最大類間變異數
        for (let t = 0; t < 256; t++) {
            wB += histogram[t];
            if (wB === 0) continue;
            wF = totalPixels - wB;
            if (wF === 0) break;

            sumB += t * histogram[t];
            let mB = sumB / wB;
            let mF = (sum - sumB) / wF;

            let varBetween = wB * wF * (mB - mF) * (mB - mF);
            if (varBetween > maxVar) {
                maxVar = varBetween;
                threshold = t;
            }
        }
        return threshold;
    }

    // 影像預處理：灰階 -> Otsu 二值化
    function preprocessCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // 1. 灰階化 (Grayscale)
        for (let i = 0; i < data.length; i += 4) {
            const avg = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            data[i] = avg;     // R
            data[i + 1] = avg; // G
            data[i + 2] = avg; // B
        }

        // 2. 計算 Otsu 閾值
        const threshold = getOtsuThreshold(imageData);
        console.log(`Otsu Threshold Calculated: ${threshold}`);

        // 3. 應用二值化 (Binarization)
        for (let i = 0; i < data.length; i += 4) {
            const val = data[i] > threshold ? 255 : 0;
            data[i] = val;
            data[i + 1] = val;
            data[i + 2] = val;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    async function handlePdfFullRead(event) {
        const file = event.target.files[0];
        if (!file) return;
        resetConversation(); 
        playAudioCue('start');
        const btn = document.getElementById('pdf-full-btn');
        const originalText = btn.innerText;
        btn.disabled = true; btn.innerText = "讀取中...";
        
        addMessage('user', `讀取 PDF: ${file.name}`);
        const resultDiv = addMessage('assistant', '正在初始化 PDF 讀取引擎...');
        
        try {
            const pdfjs = window.pdfjsLib; 
            if (!pdfjs) throw new Error("PDF.js 尚未載入");

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjs.getDocument({ 
                data: arrayBuffer,
                cMapUrl: pdfCMapUrl,
                cMapPacked: true,
            }).promise;
            
            const firstPage = await pdf.getPage(1);
            const textContent = await firstPage.getTextContent();
            const rawText = textContent.items.map(item => item.str).join('').trim();
            
            let extractedText = "";
            let mode = "TEXT";
            
            if (rawText.length < 50) {
                mode = "OCR";
                updateStatusBar(`啟用 OCR (高精度 Best 模型)...`, 'busy');
            } else {
                updateStatusBar(`文字模式提取中...`, 'busy');
            }
            
            const totalPages = pdf.numPages;
            
            if (mode === "TEXT") {
                for (let i = 1; i <= totalPages; i++) {
                    updateStatusBar(`提取文字... (${i}/${totalPages} 頁)`, 'busy');
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    extractedText += `\n--- 第 ${i} 頁 ---\n${content.items.map(item => item.str).join(' ')}\n`;
                }
            } else {
                extractedText = await performOCR(pdf, totalPages);
            }
            
            const finalDisplay = `### PDF 讀取報告\n**檔名**: ${file.name}\n**模式**: ${mode === 'OCR' ? '高精度 OCR' : '文字提取'}\n**頁數**: ${totalPages}\n\n---\n\n${extractedText}`;
            resultDiv.querySelector('.markdown-body').innerHTML = DOMPurify.sanitize(marked.parse(finalDisplay));
            
            const miniCopyBtn = resultDiv.querySelector('.mini-copy-btn');
            if (miniCopyBtn) miniCopyBtn.onclick = () => { navigator.clipboard.writeText(resultDiv.querySelector('.markdown-body').innerText).then(() => showTransientStatus("已複製內容")); };
            
            showTransientStatus("PDF 讀取完成");
            playAudioCue('success');

        } catch (e) {
            console.error(e);
            resultDiv.querySelector('.markdown-body').innerText = `錯誤: ${e.message}`;
            updateStatusBar("讀取失敗", "error");
            playAudioCue('error');
        } finally {
            btn.disabled = false; btn.innerText = originalText;
            document.getElementById('pdf-full-input').value = ""; 
        }
    }

    // OCR 執行邏輯 (使用 Tesseract Best 模型)
    async function performOCR(pdf, totalPages) {
        let fullText = "";
        
        updateStatusBar("正在載入高精度模型 (40MB+)，初次請稍候...", 'busy');
        
        // 設定 worker，強制指定 Best 模型路徑
        const worker = await Tesseract.createWorker(['chi_tra', 'chi_sim', 'eng'], 1, {
            langPath: 'https://tessdata.projectnaptha.com/4.0.0_best',
            gzip: true
        });
        
        for (let i = 1; i <= totalPages; i++) {
            updateStatusBar(`OCR 處理中 (Otsu 二值化)... 進度: ${Math.round((i/totalPages)*100)}% (第 ${i}/${totalPages} 頁)`, 'busy');
            
            const page = await pdf.getPage(i);
            const viewport = page.getViewport({ scale: 4.0 }); // 300 DPI 等級
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { willReadFrequently: true });
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            
            context.fillStyle = "#FFFFFF";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            
            // 執行強化預處理
            preprocessCanvas(canvas);
            
            const { data: { text } } = await worker.recognize(canvas);
            fullText += `\n--- 第 ${i} 頁 (OCR) ---\n${text}\n`;
        }
        
        await worker.terminate();
        return fullText;
    }

    async function extractTextFromPDF(file) {
        try {
            const pdfjs = window.pdfjsLib; 
            if (!pdfjs) return null; 

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjs.getDocument({ data: arrayBuffer, cMapUrl: pdfCMapUrl, cMapPacked: true }).promise;
            
            let firstPage = await pdf.getPage(1);
            let firstContent = await firstPage.getTextContent();
            let firstText = firstContent.items.map(item => item.str).join(' ').trim();

            if (!firstText || firstText.length < 20) return null; 

            let fullText = "";
            const maxPages = Math.min(pdf.numPages, 100);
            for (let i = 1; i <= maxPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += `[第 ${i} 頁]\n${textContent.items.map(item => item.str).join(' ')}\n`;
            }
            return fullText.trim();
        } catch (e) {
            return null; 
        }
    }

    function cleanHistoryImages(providerKey) {
        if (!chatHistory || chatHistory.length === 0) return;
        if (providerKey === 'gemini') {
            chatHistory.forEach(msg => {
                if (msg.role === 'user' && msg.parts) {
                    const originalLen = msg.parts.length;
                    msg.parts = msg.parts.filter(p => !p.inline_data);
                    if (msg.parts.length === 0 && originalLen > 0) msg.parts.push({ text: "[圖片已移除]" });
                }
            });
        } else {
            chatHistory.forEach(msg => {
                if (msg.role === 'user' && Array.isArray(msg.content)) {
                    const hasImage = msg.content.some(c => c.type === 'image_url');
                    msg.content = msg.content.filter(c => c.type === 'text');
                    if (msg.content.length === 0 && hasImage) msg.content = "[圖片已移除]";
                    else if (msg.content.length === 1 && msg.content[0].type === 'text') msg.content = msg.content[0].text;
                }
            });
        }
    }

    function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = () => reject(new Error("無法讀取檔案"));
            reader.readAsDataURL(file);
        });
    }

    async function handleSubmit(e) {
        e.preventDefault();
        const inputField = document.getElementById('user-input');
        const userInput = inputField.value.trim(); 
        const pKey = document.getElementById('provider-select').value;
        
        if (!userInput && !selectedFile) {
            showTransientStatus("請輸入內容", 'error'); 
            playAudioCue('error');
            return;
        }

        playAudioCue('start');
        updateStatusBar("正在處理...", 'busy');
        const submitBtn = document.getElementById('submit-btn');
        submitBtn.disabled = true; submitBtn.innerText = "發送中";

        const timeoutSec = parseInt(document.getElementById('timeout-setting').value) || 120;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutSec * 1000);
        const safeFileName = selectedFile ? selectedFile.name.replace(/[\[\]]/g, "") : null;
        let finalInputText = userInput;
        cleanHistoryImages(pKey);

        try {
            let fileData = null;
            let finalMimeType = null;
            let skipFileSend = false;

            if (selectedFile) {
                if (selectedFile.type === 'application/pdf') {
                    const pdfText = await extractTextFromPDF(selectedFile);
                    if (pdfText) {
                        finalInputText = `[PDF內容: ${safeFileName}]\n${pdfText}\n\n[提問]: ${userInput}`;
                        skipFileSend = true; 
                    } else {
                        fileData = await readFileAsBase64(selectedFile);
                        finalMimeType = selectedFile.type;
                    }
                } else if (selectedFile.type.startsWith('image/')) {
                    fileData = await readFileAsBase64(selectedFile);
                    finalMimeType = selectedFile.type;
                } else {
                    if (pKey === 'gemini') {
                        fileData = await readFileAsBase64(selectedFile);
                        finalMimeType = selectedFile.type;
                    } else throw new Error("此模式僅支援圖片。");
                }
            }

            const response = await callAI(pKey, finalInputText, fileData, finalMimeType, controller.signal);
            
            inputField.value = "";
            document.getElementById('upload-btn').innerText = "選擇檔案 (Alt+Shift+U)";
            document.getElementById('file-input').value = "";
            selectedFile = null; 
            
            addMessage('user', safeFileName ? `[📎 ${safeFileName}]\n${userInput}` : userInput);
            const aiMsgDiv = addMessage('assistant', response);
            
            if (pKey === 'gemini') {
                const parts = [];
                if (fileData && !skipFileSend) parts.push({ inline_data: { mime_type: finalMimeType, data: fileData } });
                parts.push({ text: skipFileSend ? finalInputText : userInput });
                chatHistory.push({ role: "user", parts: parts });
                chatHistory.push({ role: "model", parts: [{ text: response }] });
            } else {
                let content = finalInputText;
                if (fileData && !skipFileSend) {
                    content = [{ type: "text", text: finalInputText }, { type: "image_url", image_url: { url: `data:${finalMimeType};base64,${fileData}` } }];
                }
                chatHistory.push({ role: "user", content: content });
                chatHistory.push({ role: "assistant", content: response });
            }

            if (aiMsgDiv) { aiMsgDiv.scrollIntoView({ behavior: 'smooth', block: 'start' }); setTimeout(() => aiMsgDiv.focus(), 100); }
            showReadyStatus(); playAudioCue('success');
            if (navigator.vibrate) navigator.vibrate(50);

        } catch (err) {
            addMessage('user', userInput);
            const errorDiv = addMessage('error', err.name === 'AbortError' ? "連線逾時" : err.message);
            errorDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            showReadyStatus(); playAudioCue('error');
        } finally {
            clearTimeout(timeoutId);
            submitBtn.disabled = false; submitBtn.innerText = "傳送";
        }
    }

    async function callAI(provider, text, fileBase64, mimeType, signal) {
        const apiKey = document.getElementById('api-key').value;
        const prompt = document.getElementById('system-prompt').value;
        let model = currentActiveModelId;

        if (!apiKey) throw new Error("請輸入 API Key");
        let body = {}, url = "", headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

        if (provider === 'gemini') {
            url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            delete headers['Authorization']; 
            const parts = [];
            if (fileBase64) parts.push({ inline_data: { mime_type: mimeType, data: fileBase64 } });
            parts.push({ text: text });
            body = { system_instruction: { parts: [{ text: prompt }] }, contents: [...chatHistory, { role: "user", parts: parts }], tools: [{ google_search: {} }] };
        } else {
            if (provider === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";
            else if (provider === 'openrouter') {
                url = "https://openrouter.ai/api/v1/chat/completions";
                headers['HTTP-Referer'] = window.location.href; 
                headers['X-Title'] = 'AI Assistant';
                if (document.getElementById('openrouter-web-search').checked) body.plugins = [{ id: "web" }];
            }
            else if (provider === 'openai') url = "https://api.openai.com/v1/chat/completions";
            else if (provider === 'groq') url = "https://api.groq.com/openai/v1/chat/completions";
            else if (provider === 'perplexity') url = "https://api.perplexity.ai/chat/completions";

            let messages = [{ role: "system", content: prompt }, ...chatHistory];
            let content = text;
            if (fileBase64) content = [{ type: "text", text: text }, { type: "image_url", image_url: { url: `data:${mimeType};base64,${fileBase64}` } }];
            messages.push({ role: "user", content: content });
            body = { model: model, messages: messages, temperature: 0.7 };
        }

        const res = await fetch(url, { method: 'POST', headers: headers, body: JSON.stringify(body), signal: signal });
        if (!res.ok) throw new Error((await res.text()) || "API Error");
        const data = await res.json();
        
        if (provider === 'gemini') return data.candidates?.[0]?.content?.parts?.map(p => p.text).join('') || "無內容";
        else return data.choices?.[0]?.message?.content || "無內容";
    }
</script>
</body>
</html>
