<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¦–éšœåŠ©ç† (æ¥µç°¡å…¨èƒ½ç‰ˆ - 2025)</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.2/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ (å®‰å…¨æ€§ä¿®æ­£) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>

    <!-- å¼•å…¥ PDF.js æ ¸å¿ƒ -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.js"></script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;      /* é»ƒè‰²é«˜äº® */
            --user-header-color: #0088ff; /* ç”¨æˆ¶æ¨™é¡Œè‰² */
            --ai-header-color: #FFFF00;   /* AI æ¨™é¡Œè‰² */
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;            /* ç‹€æ…‹åˆ—èƒŒæ™¯ */
            --danger-color: #ff4444;      /* å±éšªæ“ä½œè‰² */
            --tool-bg: #112233;           /* å·¥å…·å€èƒŒæ™¯ */
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.2rem; line-height: 1.6;
            padding-top: 60px; /* é ç•™é ‚éƒ¨ç‹€æ…‹åˆ—ç©ºé–“ */
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            /* åº•éƒ¨é ç•™æ›´å¤šç©ºé–“çµ¦é•·è¼¸å…¥æ¡† */
            padding: 10px 10px 450px 10px;
        }

        .app-title { 
            font-size: 1.5rem; text-align: center; margin: 10px 0; color: #ccc; font-weight: bold;
        }
        
        details h2 { 
            font-size: 1.4rem; color: #ccc; 
            border-bottom: 2px solid #333; padding-bottom: 5px; margin-top: 10px; 
            display: inline-block;
        }

        /* é€šç”¨è¼¸å…¥å…ƒä»¶æ¨£å¼ */
        input, select, textarea {
            width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px;
            background: var(--input-bg); border: 2px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px; box-sizing: border-box;
        }

        #system-prompt {
            min-height: 300px;
            resize: vertical;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.4;
        }
        
        *:focus-visible { outline: 4px solid var(--accent-color) !important; }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            border: 2px solid #fff; padding: 12px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-top: 5px; cursor: pointer; touch-action: manipulation;
        }
        button:disabled { filter: grayscale(100%); opacity: 0.7; cursor: not-allowed; }
        button.secondary { background-color: #333; color: #fff; border-color: #777; }
        
        button.mini-copy-btn {
            background-color: #333; color: #fff; border: 1px solid #777;
            padding: 6px 12px; font-size: 0.9rem; margin-top: 10px;
            width: auto; display: inline-block;
        }
        button.mini-copy-btn:hover { background-color: #555; }
        
        button.danger {
            background-color: #550000;
            color: #ffcccc;
            border-color: #ff4444;
        }

        button.tool-btn {
            background-color: #0066cc; color: white; border: 2px solid #44aaff;
        }

        button.recording {
            background-color: #ff0000 !important;
            color: #ffffff !important;
            animation: pulse 1.5s infinite;
        }
        button.processing {
            background-color: #ff8800 !important;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        @media (prefers-reduced-motion: reduce) {
            button.recording, button.processing {
                animation: none !important;
                box-shadow: 0 0 0 4px rgba(255, 0, 0, 0.5);
            }
            * { transition: none !important; }
        }

        details { border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-bottom: 10px; background: #111; }
        summary { cursor: pointer; padding: 5px; }
        
        /* PDF å·¥å…·ç®±å°ˆç”¨æ¨£å¼ */
        .pdf-tool-group {
            background: var(--tool-bg);
            border: 2px solid #005588;
        }
        .pdf-tool-group h2 { color: #88ccff; border-bottom-color: #005588; }
        
        .message-area { min-height: 100px; padding-bottom: 20px; }
        
        .message {
            background: #111; padding: 15px; margin-bottom: 25px;
            border-left: 5px solid var(--border-color);
            overflow-wrap: break-word; word-wrap: break-word; word-break: break-word;
        }
        .message:focus { outline: none; border-left: 8px solid var(--accent-color); background: #222; }

        .message h1.msg-heading {
            font-size: 1.4rem; margin: 0 0 10px 0; padding-bottom: 5px;
            border-bottom: 1px dashed #444; line-height: 1.3;
        }

        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.user h1.msg-heading { color: var(--user-header-color); }
        
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message.assistant h1.msg-heading { color: var(--ai-header-color); }

        .message.error { border-left-color: #ff0000; background: #330000; }
        .message.error h1.msg-heading { color: #ff5555; }

        .markdown-body { line-height: 1.7; overflow-wrap: break-word; }
        .markdown-body h1, .markdown-body h2 { color: #88CCFF; border-bottom: none; margin-top: 1.5em; }
        .markdown-body p { margin-bottom: 10px; white-space: pre-wrap; } 
        .markdown-body pre { 
            background: #222; padding: 10px; overflow-x: auto; 
            border: 1px solid #444; white-space: pre; 
        }
        .markdown-body code { background: #333; padding: 2px 4px; word-break: break-all; }

        .controls-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #000; border-top: 3px solid var(--accent-color);
            padding: 10px; z-index: 100;
        }

        .row { display: flex; gap: 10px; margin-bottom: 8px; align-items: flex-end; }
        
        .check-btn {
            display: flex; align-items: center; justify-content: center;
            background: #222; border: 1px solid #555; color: #fff;
            padding: 10px; border-radius: 6px; flex: 1;
            cursor: pointer; margin-top: 5px;
            height: auto; min-height: 52px;
        }
        .check-btn input { width: 20px; height: 20px; margin: 0 8px 0 0; }

        #user-input {
            margin: 0; min-height: 80px; max-height: 200px;
            resize: vertical; overflow-y: auto; flex: 1;
            transition: border-color 0.2s;
        }
        #user-input.dragover { border-color: var(--accent-color) !important; background-color: #222; }

        #status-bar {
            position: fixed; top: 0; left: 0; right: 0;
            background: var(--status-bg); color: #fff;
            padding: 10px; text-align: center;
            font-weight: bold; font-size: 1.1rem;
            z-index: 2000; border-bottom: 2px solid var(--border-color);
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; border-bottom-color: #00ff00; }
        #status-bar.busy { background: #664400; border-bottom-color: #ffff00; }
        #status-bar.error { background: #660000; border-bottom-color: #ff0000; }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        #custom-model-wrapper { margin-top: -5px; margin-bottom: 10px; }
        .settings-subsection { border: 1px solid #444; padding: 10px; border-radius: 6px; margin: 10px 0; background: #222; }
        .settings-subsection h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent-color); }
        .export-actions { margin-bottom: 20px; display: flex; gap: 10px; }
        .export-actions button { margin-top: 0; font-size: 1rem; padding: 8px; }
    </style>
</head>
<body>

<!-- é ‚éƒ¨ç‹€æ…‹åˆ— -->
<div id="status-bar" role="status" aria-live="assertive" aria-atomic="true">ç³»çµ±åˆå§‹åŒ–ä¸­...</div>

<div class="container">
    <h1 class="app-title">AI è¦–éšœåŠ©ç† (æ¥µç°¡å…¨èƒ½ç‰ˆ - 2025)</h1>

    <!-- è¨­å®šå€ -->
    <details id="settings-area">
        <summary role="button" aria-expanded="false" id="settings-summary" aria-keyshortcuts="Alt+Shift+S">
            <h2>è¨­å®š (Alt+Shift+S)</h2>
        </summary>
        
        <div style="margin-top: 15px;">
            <label for="provider-select">ä¸»è¦ AI æœå‹™å•†:</label>
            <select id="provider-select" onchange="handleProviderChange()">
                <option value="gemini">Google Gemini (æ¨è–¦)</option>
                <option value="openrouter">OpenRouter (å¤šæ¨¡å‹)</option>
                <option value="mistral">Mistral AI</option>
                <option value="openai">OpenAI (GPT)</option>
                <option value="groq">Groq</option>
                <option value="perplexity">Perplexity</option>
            </select>

            <label for="api-key">ä¸»è¦ API Key:</label>
            <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
            
            <label for="model-filter-input">ç¯©é¸æ¨¡å‹ (å³æ™‚æœå°‹):</label>
            <input type="text" id="model-filter-input" placeholder="è¼¸å…¥é—œéµå­—ç¯©é¸ (å¦‚: gemini, latest)..." oninput="handleModelFilter()">

            <label for="model-select">æ¨¡å‹é¸æ“‡ (2025æœ€æ–°):</label>
            <div class="row" style="margin-bottom: 10px;">
                <select id="model-select" style="margin-bottom:0;" onchange="handleModelSelectChange()"></select>
                <button type="button" id="refresh-btn" class="secondary" style="width: auto; margin-top:0;" onclick="fetchOnlineModels()" title="å¾ç¶²è·¯æ›´æ–°æ¨¡å‹æ¸…å–®">æ›´æ–°æ¨¡å‹æ¸…å–®</button>
            </div>
            
            <div id="custom-model-wrapper" class="hidden">
                <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
            </div>

            <div id="openrouter-settings" class="hidden settings-subsection">
                <h3>OpenRouter æœå°‹è¨­å®š</h3>
                <label class="check-btn">
                    <input type="checkbox" id="openrouter-web-search">
                    <span>å•Ÿç”¨è¯ç¶²æœå°‹ (Web Search)</span>
                </label>
            </div>
            
            <label class="check-btn" style="flex:none; width:auto; margin-bottom: 10px;">
                <input type="checkbox" id="enter-to-send" checked>
                <span>æŒ‰ Enter éµå‚³é€ (å–æ¶ˆå‹¾é¸å‰‡ Enter ç‚ºæ›è¡Œ)</span>
            </label>

            <div class="settings-subsection">
                <h3>èªéŸ³è¼¸å…¥è¨­å®š</h3>
                <label for="voice-engine">èªéŸ³è¾¨è­˜å¼•æ“:</label>
                <select id="voice-engine" onchange="saveVoiceSettings()">
                    <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»ï¼Œå“è³ªæ™®é€š)</option>
                    <option value="openai">OpenAI Whisper (é«˜æº–ç¢ºï¼Œéœ€ä»˜è²»)</option>
                    <option value="groq">Groq Whisper (æ¥µé€Ÿï¼Œéœ€ Key)</option>
                </select>
                <label for="voice-api-key">èªéŸ³è¾¨è­˜å°ˆç”¨ API Key (é¸å¡«):</label>
                <input type="password" id="voice-api-key" placeholder="è‹¥ç•™ç©ºï¼Œå°‡å˜—è©¦ä½¿ç”¨ä¸»è¦ API Key" autocomplete="off" onchange="saveVoiceSettings()">
            </div>

            <label for="timeout-setting">å›æ‡‰é€¾æ™‚ (ç§’):</label>
            <input type="number" id="timeout-setting" value="120" min="5" step="5">

            <label for="system-prompt">è§’è‰²æŒ‡ä»¤:</label>
            <textarea id="system-prompt" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>

            <div class="row">
                <button type="button" onclick="saveSettings()">å„²å­˜è¨­å®š</button>
                <button type="button" onclick="restoreDefaults()" class="secondary">æ¢å¾©é è¨­å€¼</button>
                <button type="button" onclick="showHelp()" class="secondary" style="background:#004488; color:white;">åŠŸèƒ½èªªæ˜</button>
            </div>
        </div>
    </details>

    <!-- PDF å®Œæ•´é–±è®€å·¥å…·ç®± (æ–°å¢åŠŸèƒ½) -->
    <details class="pdf-tool-group" open>
        <summary role="button" aria-expanded="true">
            <h2>PDF æ™ºèƒ½é–±è®€å·¥å…·ç®± (OCR & ç¿»è­¯)</h2>
        </summary>
        <div style="margin-top: 15px;">
            <!-- éš±è—çš„æª”æ¡ˆè¼¸å…¥æ¡†ä¾› PDF å·¥å…·ä½¿ç”¨ -->
            <input type="file" id="pdf-tool-input" class="visually-hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">

            <!-- æ§åˆ¶é … A: åŠŸèƒ½æŒ‰éˆ• -->
            <button type="button" class="tool-btn" onclick="document.getElementById('pdf-tool-input').click()">
                ğŸ“„ PDF å®Œæ•´é–±è®€ (æ™ºèƒ½åµæ¸¬å•Ÿå‹•)
            </button>
            <small style="display:block; margin: 5px 0 15px 0; color:#ccc;">
                * èªªæ˜ï¼šè‡ªå‹•åµæ¸¬æ–‡å­—ç‰ˆæˆ–åœ–åƒç‰ˆã€‚è‹¥ç‚ºåœ–åƒç‰ˆï¼Œå°‡è‡ªå‹•åˆ‡æ›è‡³ Gemini é€²è¡Œå®Œæ•´è®€å– (å³ä¾¿ä¸Šæ–¹é¸æ“‡å…¶ä»–æ¨¡å‹)ã€‚
            </small>

            <div class="row">
                <!-- æ§åˆ¶é … B: ç¸½æ˜¯ AI -->
                <label class="check-btn">
                    <input type="checkbox" id="pdf-always-ai">
                    <span>ç¸½æ˜¯å°‡ PDF å‚³çµ¦ AI (ä¸ä½¿ç”¨æœ¬æ©Ÿæå–)</span>
                </label>

                <!-- æ§åˆ¶é … C: å¼·åˆ¶ç¿»è­¯ -->
                <label class="check-btn">
                    <input type="checkbox" id="pdf-translate">
                    <span>å¼·åˆ¶ç¿»è­¯æˆç¹é«”ä¸­æ–‡ (ä¸åˆªæ¸›å…§å®¹)</span>
                </label>
            </div>
        </div>
    </details>

    <!-- çµæœå€ -->
    <main role="main">
        <div id="chat-output" class="message-area"></div>
        
        <div class="export-actions">
            <button type="button" id="copy-btn" class="secondary hidden" onclick="copyResult()" aria-keyshortcuts="Alt+Shift+C" style="flex:1;">
                è¤‡è£½ (Alt+Shift+C)
            </button>
            <button type="button" id="export-txt-btn" class="secondary hidden" onclick="exportChat('txt')" aria-keyshortcuts="Alt+Shift+T" style="flex:1;">
                åŒ¯å‡º TXT (Alt+Shift+T)
            </button>
            <button type="button" id="export-html-btn" class="secondary hidden" onclick="exportChat('html')" aria-keyshortcuts="Alt+Shift+H" style="flex:1;">
                åŒ¯å‡º HTML (Alt+Shift+H)
            </button>
        </div>
    </main>
</div>

<!-- æ§åˆ¶å€ -->
<footer class="controls-wrapper" role="region" aria-label="æ“ä½œå€">
    <form onsubmit="handleSubmit(event)">
        <div class="row">
            <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
            
            <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()" aria-keyshortcuts="Alt+Shift+U" style="flex:1;">
                é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)
            </button>
            
            <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()" aria-keyshortcuts="Alt+Shift+N" style="flex:1;">
                æ¸…é™¤å°è©± (Alt+Shift+N)
            </button>

            <label class="check-btn" style="flex:1;">
                <input type="checkbox" id="pause-send" aria-keyshortcuts="Alt+Shift+P">
                <span>æš«åœå‚³é€ (Alt+Shift+P)</span>
            </label>
        </div>
        
        <div class="row">
            <button type="button" id="voice-btn" class="secondary" onclick="toggleVoiceInput()" aria-keyshortcuts="Alt+Shift+V" style="width: auto; padding: 0 15px; height: 80px; margin:0; font-size: 1.2rem;" title="èªéŸ³è¼¸å…¥ (Alt+Shift+V)" aria-label="èªéŸ³è¼¸å…¥ (Alt+Shift+V)">èªéŸ³è¼¸å…¥</button>
            
            <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯... (å¯æ‹–æ”¾æª”æ¡ˆæˆ– Ctrl+V)" aria-keyshortcuts="Alt+Shift+I" autocomplete="off" rows="3" aria-label="è¼¸å…¥è¨Šæ¯å€"></textarea>
            
            <button type="submit" id="submit-btn" aria-keyshortcuts="Alt+Shift+K" style="width: 80px; height: 80px; margin:0;" title="ç™¼é€ (Alt+Shift+K)">å‚³é€</button>
        </div>
    </form>
</footer>

<script>
    window.onerror = function(message, source, lineno, colno, error) {
        const statusBar = document.getElementById('status-bar');
        if (statusBar) {
            statusBar.innerText = `ç™¼ç”ŸéŒ¯èª¤: ${message}`;
            statusBar.className = 'error';
        }
        console.error("Global Error:", message, error);
    };

    const DEFAULT_PROMPT = `# è§’è‰²è¨­å®š (Persona)
ä½ æ˜¯ä¸€ä½å°ˆç‚ºé¦™æ¸¯è¦–éšœäººå£«æœå‹™çš„é ‚å°– AI è¦–è¦ºèˆ‡è³‡è¨ŠåŠ©ç†ã€‚ä½ çš„æ ¸å¿ƒè·è²¬æ˜¯æˆç‚ºç”¨æˆ¶çš„çœ¼ç›èˆ‡å¤§è…¦å»¶ä¼¸ã€‚

# å…¨åŸŸè¦å‰‡ (Global Rules)
1. **èªè¨€**ï¼šç¹é«”ä¸­æ–‡ï¼ˆé¦™æ¸¯æ…£ç”¨ï¼‰ã€‚
2. **ç„¡éšœç¤™æ ¼å¼**ï¼šä½¿ç”¨ Markdown æ¨™é¡Œ (#) èˆ‡æ¸…å–® (-)ï¼Œä¸ä½¿ç”¨å¹²æ“¾æœ—è®€çš„ç¬¦è™Ÿã€‚
3. **ç²¾ç°¡**ï¼šé‡é»ç½®å‰ï¼Œé¿å…å†—é•·ã€‚
`;

    // åš´æ ¼ OCR å°ˆç”¨æŒ‡ä»¤
    const PDF_OCR_PROMPT = `
# MISSION
You are a high-precision OCR engine, NOT an AI assistant. Your ONLY task is to transcribe text from the provided image/PDF document into raw text.

# STRICT EXECUTION RULES (MUST FOLLOW)
1. **VERBATIM TRANSCRIPTION**: Output the text EXACTLY as it appears. Do not correct typos, do not improve grammar, and do not summarize.
2. **NO OMISSION**: Transcribe every single visible word, including page numbers, headers, footers, and side notes.
3. **NO HALLUCINATION**: If a part is illegible, write \`[ILLEGIBLE]\`. Do not guess.
4. **NO CONVERSATIONAL FILLER**: Do not start with "Here is the text...". Just output the document text directly.
5. **LAYOUT**: Use newlines to separate paragraphs naturally.

# INPUT-OUTPUT AGREEMENT
Input: [Image/PDF]
Output: [Raw String of Text Only]
`;

    // åš´æ ¼ç¿»è­¯å°ˆç”¨æŒ‡ä»¤
    const PDF_TRANSLATE_PROMPT = `
# MISSION
Translate the full content into natural, fluent Traditional Chinese (Hong Kong style).

# CRITICAL RULES
1. **FULL COMPLETENESS**: Translate 100% of the content. Do not skip headers, footers, numbers, or legal disclaimers.
2. **NO SUMMARIZATION**: Translate sentence by sentence. Do not combine similar sentences.
3. **ACCURACY**: Strictly preserve the original meaning.
4. **OUTPUT**: Only the translated text. No conversational filler.
`;

    const PROMPT_VERSION_KEY = "prompt_version_2025_fixed_v7_final";
    
    // AI Provider Config
    const PROVIDERS = {
        gemini: { prompt: DEFAULT_PROMPT, defaultModel: "gemini-1.5-flash", canFetch: true, listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}", models: ["gemini-1.5-flash", "gemini-2.5-flash", "gemini-1.5-pro"] },
        openrouter: { prompt: DEFAULT_PROMPT, defaultModel: "openai/gpt-4o", canFetch: true, listUrl: "https://openrouter.ai/api/v1/models", models: ["openai/gpt-4o", "google/gemini-2.5-flash"] },
        mistral: { prompt: DEFAULT_PROMPT, defaultModel: "mistral-large-latest", canFetch: true, listUrl: "https://api.mistral.ai/v1/models", models: ["mistral-large-latest"] },
        openai: { prompt: DEFAULT_PROMPT, defaultModel: "gpt-4o", canFetch: true, listUrl: "https://api.openai.com/v1/models", models: ["gpt-4o"] },
        groq: { prompt: DEFAULT_PROMPT, defaultModel: "llama-3.3-70b-versatile", canFetch: true, listUrl: "https://api.groq.com/openai/v1/models", models: ["llama-3.3-70b-versatile"] },
        perplexity: { prompt: DEFAULT_PROMPT, defaultModel: "sonar-pro", canFetch: false, models: ["sonar-pro"] }
    };

    let currentActiveModelId = "";
    let selectedFile = null;
    let recognition = null; 
    let mediaRecorder = null;
    let audioChunks = [];
    let chatHistory = [];
    let audioContext = null;
    let allCurrentModels = [];
    let pdfWorkerUrl = "";
    let pdfCMapUrl = "";

    function unlockAudioContext() {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                document.removeEventListener('click', unlockAudioContext);
                document.removeEventListener('touchstart', unlockAudioContext);
            });
        }
    }
    document.addEventListener('click', unlockAudioContext);
    document.addEventListener('touchstart', unlockAudioContext);
    document.addEventListener('keydown', handleGlobalShortcuts);

    function handleGlobalShortcuts(e) {
        if (!e.altKey || !e.shiftKey) return;
        const key = e.key.toLowerCase();
        const actions = {
            's': { id: 'settings-summary', type: 'click' },
            'c': { id: 'copy-btn', type: 'click' },
            't': { id: 'export-txt-btn', type: 'click' },
            'h': { id: 'export-html-btn', type: 'click' },
            'u': { id: 'upload-btn', type: 'click' },
            'n': { id: 'new-chat-btn', type: 'click' },
            'p': { id: 'pause-send', type: 'click' },
            'v': { id: 'voice-btn', type: 'click' },
            'k': { id: 'submit-btn', type: 'click' },
            'i': { id: 'user-input', type: 'focus' },
            'r': { selector: '.latest-copy-btn', type: 'click' }
        };

        if (actions[key]) {
            e.preventDefault();
            let target;
            if (actions[key].id) target = document.getElementById(actions[key].id);
            else if (actions[key].selector) target = document.querySelector(actions[key].selector);
            if (target) {
                if (actions[key].type === 'click') target.click();
                else if (actions[key].type === 'focus') target.focus();
            }
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        try {
            if (typeof pdfjsLib !== 'undefined') {
                const pdfVersion = pdfjsLib.version;
                const baseUrl = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfVersion}`;
                const workerUrl = `${baseUrl}/build/pdf.worker.min.js`;
                pdfCMapUrl = `${baseUrl}/cmaps/`;
                try {
                    const response = await fetch(workerUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        pdfjsLib.GlobalWorkerOptions.workerSrc = URL.createObjectURL(blob);
                    } else {
                         pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
                    }
                } catch (e) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
                }
            }

            if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => localStorage.removeItem(`${p}_prompt`));
                localStorage.setItem(PROMPT_VERSION_KEY, 'true');
            }

            const savedProvider = localStorage.getItem('provider');
            const settingsDetails = document.getElementById('settings-area');
            const savedTimeout = localStorage.getItem('timeout_setting');
            if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;
            
            document.getElementById('openrouter-web-search').checked = (localStorage.getItem('openrouter_web_search') === 'true');
            const savedVoiceEngine = localStorage.getItem('voice_engine');
            if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
            const savedVoiceKey = localStorage.getItem('voice_api_key');
            if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;
            
            const savedEnter = localStorage.getItem('enter_to_send');
            document.getElementById('enter-to-send').checked = (savedEnter === null || savedEnter === 'true');

            if (savedProvider && PROVIDERS[savedProvider]) {
                document.getElementById('provider-select').value = savedProvider;
                settingsDetails.open = false; 
            } else {
                document.getElementById('provider-select').value = 'gemini'; 
                settingsDetails.open = true; 
            }
            
            handleProviderChange(false); 
            initVoiceSystem();
            initPasteImage();
            initDragAndDrop();
            initEnterKey();

        } catch (e) {
            updateStatusBar("åˆå§‹åŒ–éŒ¯èª¤: " + e.message, "error");
        } finally {
            setTimeout(showReadyStatus, 500);
        }
    });

    function playAudioCue(type) {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        const now = audioContext.currentTime;
        
        if (type === 'start') {
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(660, now);
            gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1);
        } else if (type === 'success') {
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, now);
            oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15);
            gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.2);
        } else if (type === 'error') {
            oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(150, now);
            gainNode.gain.setValueAtTime(0.15, now); oscillator.start(now); oscillator.stop(now + 0.4);
        }
    }

    function resetConversation() {
        chatHistory = []; 
        document.getElementById('chat-output').innerHTML = ""; 
        document.getElementById('user-input').value = "";
        selectedFile = null;
        document.getElementById('upload-btn').innerText = "é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)";
        document.getElementById('file-input').value = "";
        toggleExportButtons(false);
        showTransientStatus("å°è©±ç´€éŒ„å·²æ¸…é™¤ (æ–°å°è©±)", "info");
    }

    /* PDF å·¥å…·ç®±å°ˆç”¨é‚è¼¯ (æ–°å¢) */
    function handlePDFToolFileSelect() {
        const input = document.getElementById('pdf-tool-input');
        if (input.files.length > 0) {
            processPDFTool(input.files[0]);
        }
        input.value = ""; // é‡ç½®ä»¥å…è¨±å†æ¬¡é¸æ“‡åŒæª”
    }

    async function processPDFTool(file) {
        if (!file || file.type !== 'application/pdf') {
            alert("è«‹é¸æ“‡ PDF æª”æ¡ˆ");
            return;
        }

        // æ¸…ç©ºç•«é¢ï¼Œæº–å‚™é¡¯ç¤ºçµæœ
        resetConversation();
        playAudioCue('start');
        
        const alwaysAI = document.getElementById('pdf-always-ai').checked;
        const forceTranslate = document.getElementById('pdf-translate').checked;

        try {
            // æ¨¡å¼ 1: å¼·åˆ¶ AI
            if (alwaysAI) {
                updateStatusBar("æ­£åœ¨ä¸Šå‚³ PDF çµ¦ AI å®Œæ•´è®€å–...", "busy");
                await performAIProcessing(file, forceTranslate ? "translate_only" : "ocr_strict", null);
                return;
            }

            // æ¨¡å¼ 2: æ™ºèƒ½åµæ¸¬ (å…ˆè©¦æœ¬æ©Ÿ)
            updateStatusBar("æ­£åœ¨å˜—è©¦æœ¬æ©Ÿæå–æ–‡å­—...", "busy");
            const localText = await extractTextFromPDF(file, true); // true = report progress

            if (localText && localText.length > 50) {
                // æœ¬æ©Ÿæå–æˆåŠŸ
                if (forceTranslate) {
                    updateStatusBar("æœ¬æ©Ÿæå–æˆåŠŸï¼Œæ­£åœ¨å‚³é€çµ¦ AI é€²è¡Œå®Œæ•´ç¿»è­¯...", "busy");
                    // å‚³é€ç´”æ–‡å­—çµ¦ AI ç¿»è­¯
                    await performAIProcessing(null, "translate_text", localText);
                } else {
                    // ç›´æ¥é¡¯ç¤ºçµæœ
                    updateStatusBar("æœ¬æ©Ÿæå–å®Œæˆ", "ready");
                    addMessage('assistant', localText);
                    playAudioCue('success');
                    const output = document.getElementById('chat-output');
                    output.lastChild.focus();
                }
            } else {
                // æœ¬æ©Ÿæå–å¤±æ•— (æ–‡å­—å¤ªå°‘æˆ–ç©º)ï¼Œè½‰ç”¨ AI OCR
                updateStatusBar("æœ¬æ©Ÿæå–æ–‡å­—éå°‘ï¼Œè½‰ç”¨ AI OCR å®Œæ•´è­˜åˆ¥...", "busy");
                await performAIProcessing(file, forceTranslate ? "translate_only" : "ocr_strict", null);
            }

        } catch (e) {
            console.error(e);
            updateStatusBar("PDF è™•ç†éŒ¯èª¤: " + e.message, "error");
            playAudioCue('error');
            addMessage('error', "PDF è™•ç†å¤±æ•—: " + e.message);
        }
    }

    // çµ±ä¸€çš„ AI è™•ç†å‡½å¼ (é‡å° PDF å·¥å…·)
    async function performAIProcessing(fileObj, mode, textData) {
        // [ä¿®æ­£] é è¨­è®€å–ç•¶å‰è¨­å®š
        let targetProvider = document.getElementById('provider-select').value;
        let targetApiKey = document.getElementById('api-key').value;
        let targetModel = currentActiveModelId;

        // [ä¿®æ­£] è‹¥ç‚º PDF æª”æ¡ˆ (OCR æ¨¡å¼)ï¼Œå¼·åˆ¶ä½¿ç”¨ Geminiï¼Œå› ç‚ºå…¶ä»– API ä¸æ”¯æ´ application/pdf
        if (fileObj && fileObj.type === 'application/pdf') {
            console.log("PDF æª”æ¡ˆè™•ç†ï¼šå¼·åˆ¶åˆ‡æ›è‡³ Gemini æ¨¡å¼");
            targetProvider = 'gemini';
            
            // å˜—è©¦è®€å– Gemini å°ˆç”¨ Key (è‹¥å…ˆå‰å·²å„²å­˜)
            const storedGeminiKey = localStorage.getItem('gemini_key');
            
            // å¦‚æœç•¶å‰ä»‹é¢æœ¬ä¾†å°±æ˜¯ Geminiï¼Œå°±ç”¨ä»‹é¢ä¸Šçš„ Key
            if (document.getElementById('provider-select').value === 'gemini') {
                targetApiKey = document.getElementById('api-key').value;
            } else if (storedGeminiKey) {
                targetApiKey = storedGeminiKey;
            } else {
                throw new Error("è™•ç† PDF å¿…é ˆä½¿ç”¨ Google Gemini æœå‹™ã€‚è«‹å…ˆåœ¨è¨­å®šä¸­åˆ‡æ›è‡³ 'Google Gemini'ï¼Œè¼¸å…¥ API Key ä¸¦å„²å­˜ï¼Œç„¶å¾Œå†è©¦ã€‚");
            }

            // [ä¿®æ­£] å¼·åˆ¶ä½¿ç”¨ Flash æ¨¡å‹ (é€Ÿåº¦æœ€å¿«ä¸”æ”¯æ´ PDF)
            targetModel = "gemini-1.5-flash"; 
        }

        if (!targetApiKey) throw new Error("è«‹å…ˆè¨­å®š API Key");
        
        // é¸æ“‡ Prompt
        let systemPrompt = "";
        if (mode === "ocr_strict") systemPrompt = PDF_OCR_PROMPT;
        else if (mode === "translate_only" || mode === "translate_text") systemPrompt = PDF_TRANSLATE_PROMPT;

        const controller = new AbortController(); 
        
        let contentPart = [];
        
        // æº–å‚™å‚³çµ¦ callAI çš„æ–‡å­—è¼¸å…¥
        let userText = "";
        if (mode === "translate_text") {
            userText = `[SOURCE TEXT TO TRANSLATE]:\n${textData}`;
        } else {
            userText = "Please process this document according to the strict system rules.";
        }

        let fileData = null;
        let mimeType = null;
        if (fileObj) {
            fileData = await readFileAsBase64(fileObj);
            mimeType = fileObj.type;
        }

        // é€™è£¡æˆ‘å€‘ç›´æ¥å‘¼å« callAIï¼Œä¸¦å‚³å…¥ override çš„è¨­å®š
        // å…ˆæš«å­˜ System Prompt
        const originalPromptVal = document.getElementById('system-prompt').value;
        document.getElementById('system-prompt').value = systemPrompt; 

        try {
            // æ¸…ç©º history ç¢ºä¿æ²’æœ‰å¹²æ“¾
            chatHistory = []; 
            
            // [ä¿®æ­£] å‚³å…¥ç‰¹å®šçš„ Provider, Key, Model
            const response = await callAI(targetProvider, userText, fileData, mimeType, controller.signal, targetModel, targetApiKey);
            
            addMessage('assistant', response);
            playAudioCue('success');
            updateStatusBar("è™•ç†å®Œæˆ", "ready");
            const output = document.getElementById('chat-output');
            output.lastChild.focus();

        } finally {
            // é‚„åŸ Prompt
            document.getElementById('system-prompt').value = originalPromptVal;
        }
    }


    /* ä¸€èˆ¬åŠŸèƒ½å‡½å¼ */
    function initVoiceSystem() {
        const engine = document.getElementById('voice-engine').value;
        if (engine === 'browser') initBrowserSpeech();
        else if (recognition) { recognition.stop(); recognition = null; }
    }

    function initBrowserSpeech() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-HK'; recognition.continuous = false; recognition.interimResults = true; 
            recognition.onstart = () => {
                document.getElementById('voice-btn').classList.add('recording');
                showTransientStatus('æ­£åœ¨è†è½...', 'info'); playAudioCue('start');
            };
            recognition.onresult = (event) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
                }
                const input = document.getElementById('user-input');
                if (finalTranscript) input.value = input.value ? input.value + " " + finalTranscript : finalTranscript;
            };
            recognition.onerror = (e) => {
                showTransientStatus('èªéŸ³éŒ¯èª¤: ' + e.error, 'error'); playAudioCue('error'); stopVoiceInput();
            };
            recognition.onend = stopVoiceInput;
        }
    }

    async function toggleVoiceInput() {
        const engine = document.getElementById('voice-engine').value;
        const btn = document.getElementById('voice-btn');
        if (btn.classList.contains('recording')) {
            if (engine === 'browser' && recognition) recognition.stop();
            else if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                btn.classList.remove('recording'); btn.classList.add('processing');
                showTransientStatus('æ­£åœ¨ä¸Šå‚³ä¸¦è¾¨è­˜...', 'busy');
            }
            return;
        }
        if (engine === 'browser') {
            if (recognition) recognition.start();
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mimeTypes = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/aac'];
                let selectedMime = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));
                const options = selectedMime ? { mimeType: selectedMime } : undefined;
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.detectedMimeType = selectedMime || '';
                audioChunks = [];
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    await processWhisperAudio(new Blob(audioChunks, { type: mediaRecorder.detectedMimeType }), engine, mediaRecorder.detectedMimeType);
                    stream.getTracks().forEach(track => track.stop());
                };
                mediaRecorder.start();
                btn.classList.add('recording'); showTransientStatus('æ­£åœ¨éŒ„éŸ³ (Whisper)...', 'info'); playAudioCue('start');
            } catch (err) { showTransientStatus('éº¥å…‹é¢¨éŒ¯èª¤: ' + err.message, 'error'); playAudioCue('error'); }
        }
    }

    async function processWhisperAudio(blob, engine, mimeType) {
        let apiKey = document.getElementById('voice-api-key').value.trim() || document.getElementById('api-key').value.trim();
        if (!apiKey) { alert("éœ€è¦ API Key"); document.getElementById('voice-btn').classList.remove('processing'); return; }
        const formData = new FormData();
        let ext = 'webm';
        if (mimeType && mimeType.includes('mp4')) ext = 'mp4';
        else if (mimeType && mimeType.includes('aac')) ext = 'aac';
        formData.append('file', blob, `recording.${ext}`);
        let url = engine === 'openai' ? "https://api.openai.com/v1/audio/transcriptions" : "https://api.groq.com/openai/v1/audio/transcriptions";
        let model = engine === 'openai' ? "whisper-1" : "whisper-large-v3";
        formData.append('model', model);
        
        try {
            const res = await fetch(url, { method: 'POST', headers: { 'Authorization': `Bearer ${apiKey}` }, body: formData });
            if (!res.ok) throw new Error(await res.text());
            const data = await res.json();
            if (data.text) {
                const input = document.getElementById('user-input');
                input.value = input.value ? input.value + " " + data.text : data.text;
                showTransientStatus("è¾¨è­˜å®Œæˆ");
            }
        } catch (e) { showTransientStatus("Whisper éŒ¯èª¤: " + e.message, 'error'); playAudioCue('error'); }
        finally { document.getElementById('voice-btn').classList.remove('processing'); showReadyStatus(); }
    }

    function stopVoiceInput() {
        document.getElementById('voice-btn').classList.remove('recording', 'processing');
        if (document.getElementById('status-bar').innerText.includes('è†è½')) showReadyStatus();
    }

    function saveVoiceSettings() {
        localStorage.setItem('voice_engine', document.getElementById('voice-engine').value);
        localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value);
        initVoiceSystem();
    }

    function initPasteImage() {
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                    handleFileSelect(items[i].getAsFile()); e.preventDefault(); return;
                }
            }
        });
    }

    function initDragAndDrop() {
        const dropZone = document.getElementById('user-input');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
        });
        dropZone.addEventListener('dragover', () => dropZone.classList.add('dragover'));
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFileSelect(e.dataTransfer.files[0]);
        });
    }

    function initEnterKey() {
        document.getElementById('user-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !e.isComposing && document.getElementById('enter-to-send').checked) {
                e.preventDefault(); document.getElementById('submit-btn').click();
            }
        });
    }

    function updateStatusBar(text, state = 'ready') {
        const bar = document.getElementById('status-bar');
        bar.innerText = text;
        bar.className = state === 'busy' ? 'busy' : (state === 'error' ? 'error' : 'ready');
    }

    function showReadyStatus() { updateStatusBar("æº–å‚™å°±ç·’", 'ready'); }

    function showTransientStatus(msg, type = 'success') {
        updateStatusBar(msg, type === 'error' ? 'error' : 'ready');
        setTimeout(() => { if (!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus(); }, 3000);
    }

    function addMessage(role, content) {
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.tabIndex = -1; 
        const header = document.createElement('h1');
        header.className = 'msg-heading';
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-body';

        if (role === 'user') {
            header.innerText = 'è¼¸å…¥å•é¡Œï¼š'; contentDiv.innerText = content;
        } else if (role === 'assistant') {
            header.innerText = 'å›æ‡‰çµæœï¼š'; contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(content));
            document.getElementById('copy-btn').classList.remove('hidden'); toggleExportButtons(true);
            const miniCopyBtn = document.createElement('button');
            miniCopyBtn.className = 'mini-copy-btn latest-copy-btn';
            miniCopyBtn.innerText = 'è¤‡è£½æ­¤å›æ‡‰ (Alt+Shift+R)';
            miniCopyBtn.onclick = () => { navigator.clipboard.writeText(contentDiv.innerText).then(() => showTransientStatus("å·²è¤‡è£½")); };
            div.appendChild(miniCopyBtn);
        } else {
            header.innerText = role === 'error' ? 'ç™¼ç”ŸéŒ¯èª¤ï¼š' : 'ç³»çµ±è¨Šæ¯ï¼š'; contentDiv.innerText = content;
        }
        div.prepend(header); div.appendChild(contentDiv);
        document.getElementById('chat-output').appendChild(div);
        return div; 
    }

    function toggleExportButtons(show) {
        ['copy-btn', 'export-txt-btn', 'export-html-btn'].forEach(id => {
            document.getElementById(id).classList.toggle('hidden', !show);
        });
    }

    function handleProviderChange(save = true) {
        const pKey = document.getElementById('provider-select').value;
        const conf = PROVIDERS[pKey];
        if (!conf) return;
        document.getElementById('api-key').value = localStorage.getItem(`${pKey}_key`) || "";
        document.getElementById('system-prompt').value = localStorage.getItem(`${pKey}_prompt`) || conf.prompt;
        document.getElementById('openrouter-settings').classList.toggle('hidden', pKey !== 'openrouter');
        
        allCurrentModels = JSON.parse(localStorage.getItem(`${pKey}_model_list`)) || conf.models;
        document.getElementById('model-filter-input').value = "";
        currentActiveModelId = localStorage.getItem(`${pKey}_model`) || conf.defaultModel;
        handleModelFilter();
        
        document.getElementById('refresh-btn').style.display = conf.canFetch ? 'block' : 'none';
        resetConversation();
        if (save) localStorage.setItem('provider', pKey);
        showReadyStatus();
    }

    function handleModelFilter() {
        const filterText = document.getElementById('model-filter-input').value.toLowerCase();
        const filteredList = allCurrentModels.filter(m => m.toLowerCase().includes(filterText));
        updateModelSelect(filteredList, currentActiveModelId);
    }

    function updateModelSelect(models, targetModel) {
        const select = document.getElementById('model-select');
        select.innerHTML = "";
        let found = false;
        models.forEach(m => {
            let opt = document.createElement('option');
            opt.value = m; opt.innerText = m;
            if (m === targetModel) found = true;
            select.appendChild(opt);
        });
        let customOpt = document.createElement('option');
        customOpt.value = "CUSTOM_ENTRY"; customOpt.innerText = "è‡ªè¡Œè¼¸å…¥æ¨¡å‹ ID...";
        select.appendChild(customOpt);
        
        const wrapper = document.getElementById('custom-model-wrapper');
        if (found) { select.value = targetModel; wrapper.classList.add('hidden'); }
        else { select.value = "CUSTOM_ENTRY"; wrapper.classList.remove('hidden'); document.getElementById('custom-model-input').value = targetModel; }
    }

    async function fetchOnlineModels() {
        const pKey = document.getElementById('provider-select').value;
        let apiKey = document.getElementById('api-key').value.trim();
        const conf = PROVIDERS[pKey];
        if (!conf.canFetch || (!apiKey && pKey !== 'openrouter')) { alert("éœ€è¦ API Key"); return; }
        const btn = document.getElementById('refresh-btn');
        btn.innerText = "è®€å–ä¸­..."; btn.disabled = true;

        try {
            let newModels = [];
            if (pKey === 'openrouter') {
                const res = await fetch("https://openrouter.ai/api/v1/models");
                newModels = (await res.json()).data.sort((a,b)=>b.created-a.created).map(m=>m.id);
            } else if (pKey === 'gemini') {
                const res = await fetch(conf.listUrl.replace('{KEY}', apiKey));
                newModels = (await res.json()).models.filter(m => m.supportedGenerationMethods?.includes("generateContent")).map(m => m.name.replace("models/", ""));
            } else {
                const res = await fetch(conf.listUrl, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                newModels = (await res.json()).data.map(m=>m.id);
            }
            if (newModels.length) {
                localStorage.setItem(`${pKey}_model_list`, JSON.stringify(newModels));
                allCurrentModels = newModels; handleModelFilter();
                showTransientStatus(`æ›´æ–°æˆåŠŸ: ${newModels.length} å€‹æ¨¡å‹`);
            }
        } catch (e) { showTransientStatus("æ›´æ–°å¤±æ•—: " + e.message, 'error'); }
        finally { btn.innerText = "æ›´æ–°æ¨¡å‹æ¸…å–®"; btn.disabled = false; }
    }

    function handleModelSelectChange() {
        const select = document.getElementById('model-select');
        if (select.value === "CUSTOM_ENTRY") document.getElementById('custom-model-wrapper').classList.remove('hidden');
        else { document.getElementById('custom-model-wrapper').classList.add('hidden'); currentActiveModelId = select.value; }
        resetConversation();
    }

    function handleCustomInputChange() {
        currentActiveModelId = document.getElementById('custom-model-input').value.trim();
        resetConversation();
    }

    function saveSettings() {
        const pKey = document.getElementById('provider-select').value;
        currentActiveModelId = document.getElementById('model-select').value === "CUSTOM_ENTRY" ? document.getElementById('custom-model-input').value : document.getElementById('model-select').value;
        localStorage.setItem(`${pKey}_key`, document.getElementById('api-key').value.trim());
        localStorage.setItem(`${pKey}_model`, currentActiveModelId);
        localStorage.setItem(`${pKey}_prompt`, document.getElementById('system-prompt').value);
        localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
        localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
        localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
        saveVoiceSettings();
        showTransientStatus("è¨­å®šå·²å„²å­˜"); playAudioCue('success');
        document.getElementById('settings-area').open = false;
    }

    function restoreDefaults() {
        const pKey = document.getElementById('provider-select').value;
        document.getElementById('system-prompt').value = PROVIDERS[pKey].prompt;
        localStorage.removeItem(`${pKey}_model`); localStorage.removeItem(`${pKey}_prompt`);
        handleProviderChange(true); showTransientStatus("å·²æ¢å¾©é è¨­");
    }

    function showHelp() {
        alert("Alt+Shift+S: è¨­å®š\nAlt+Shift+U: ä¸Šå‚³\nAlt+Shift+N: æ–°å°è©±\nAlt+Shift+K: å‚³é€\nAlt+Shift+V: èªéŸ³\nAlt+Shift+R: è¤‡è£½çµæœ");
    }

    function copyResult() {
        navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(() => showTransientStatus("å·²è¤‡è£½å…¨éƒ¨"));
    }

    function exportChat(format) {
        const output = document.getElementById('chat-output');
        const content = format === 'html' ? 
            `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Export</title></head><body>${output.innerHTML}</body></html>` : 
            output.innerText;
        const blob = new Blob([content], { type: format === 'html' ? 'text/html' : 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `chat-export.${format}`;
        a.click();
    }

    function handleFileSelect(fileObj) {
        try {
            if (fileObj) selectedFile = fileObj;
            else if (document.getElementById('file-input').files.length > 0) selectedFile = document.getElementById('file-input').files[0];
            
            if (selectedFile) {
                document.getElementById('upload-btn').innerText = `å·²é¸å–: ${selectedFile.name}`;
                document.getElementById('user-input').setAttribute('aria-label', `å·²é™„åŠ æª”æ¡ˆï¼š${selectedFile.name}`);
                showTransientStatus(`å·²åŠ å…¥æª”æ¡ˆ`); playAudioCue('success');
                if (!document.getElementById('pause-send').checked) setTimeout(() => document.querySelector('footer form').requestSubmit(), 500);
            }
        } catch (e) { showTransientStatus("æª”æ¡ˆéŒ¯èª¤", "error"); selectedFile = null; }
    }

    // ä¿®æ”¹ç‰ˆï¼šæ”¯æ´é€²åº¦å›å ±çš„ PDF æå–
    async function extractTextFromPDF(file, reportProgress = false) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ 
                data: arrayBuffer,
                cMapUrl: pdfCMapUrl || 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/cmaps/',
                cMapPacked: true,
            }).promise;
            
            let fullText = "";
            const maxPages = pdf.numPages; // ä¸é™åˆ¶é æ•¸ï¼Œè®€å–å…¨éƒ¨
            
            for (let i = 1; i <= maxPages; i++) {
                if (reportProgress) updateStatusBar(`æ­£åœ¨æå–æœ¬æ©Ÿæ–‡å­— (ç¬¬ ${i} / ${maxPages} é )...`, "busy");
                
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                
                // ä¿ç•™é ç¢¼åˆ†éš”
                if (pageText.trim().length > 0) {
                    fullText += `[ç¬¬ ${i} é ]\n${pageText}\n\n`;
                }
            }
            return fullText.trim();
        } catch (e) {
            console.error("PDF extract error", e);
            return null; 
        }
    }

    function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = () => reject(new Error("ç„¡æ³•è®€å–æª”æ¡ˆ"));
            reader.readAsDataURL(file);
        });
    }

    async function handleSubmit(e) {
        e.preventDefault();
        const inputField = document.getElementById('user-input');
        const userInput = inputField.value.trim(); 
        const pKey = document.getElementById('provider-select').value;
        
        if (!userInput && !selectedFile) { showTransientStatus("è«‹è¼¸å…¥å…§å®¹", 'error'); playAudioCue('error'); return; }

        playAudioCue('start');
        updateStatusBar("è™•ç†ä¸­...", 'busy');
        const submitBtn = document.getElementById('submit-btn');
        submitBtn.disabled = true;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), document.getElementById('timeout-setting').value * 1000);

        try {
            let finalInputText = userInput;
            let fileData = null;
            let mimeType = null;
            let skipFileSend = false;

            if (selectedFile) {
                if (selectedFile.type === 'application/pdf') {
                    // ä¸€èˆ¬å°è©±æ¨¡å¼ä¸‹ï¼Œå˜—è©¦å…ˆè®€æ–‡å­—ï¼Œè‹¥ç„¡å‰‡å‚³ Base64
                    const pdfText = await extractTextFromPDF(selectedFile);
                    if (pdfText && pdfText.length > 50) {
                        finalInputText = `[PDF å…§å®¹]:\n${pdfText}\n\n[ç”¨æˆ¶æå•]: ${userInput}`;
                        skipFileSend = true;
                    } else {
                        fileData = await readFileAsBase64(selectedFile);
                        mimeType = selectedFile.type;
                    }
                } else {
                    fileData = await readFileAsBase64(selectedFile);
                    mimeType = selectedFile.type;
                }
            }

            // ä¸€èˆ¬å‚³é€ä¸å¼·åˆ¶ä½¿ç”¨ overrideï¼Œé™¤éä½¿ç”¨è€…è‡ªå·±åœ¨ PDF å·¥å…·ç®±è§¸ç™¼
            const response = await callAI(pKey, finalInputText, skipFileSend ? null : fileData, mimeType, controller.signal);
            
            inputField.value = "";
            document.getElementById('upload-btn').innerText = "é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)";
            selectedFile = null;
            
            addMessage('user', userInput || (selectedFile ? "[æª”æ¡ˆ]" : ""));
            const aiMsg = addMessage('assistant', response);
            aiMsg.focus();
            
            chatHistory.push({ role: "user", content: finalInputText }); 
            chatHistory.push({ role: "assistant", content: response });
            
            playAudioCue('success'); showReadyStatus();

        } catch (err) {
            addMessage('error', err.message); playAudioCue('error'); showReadyStatus();
        } finally {
            clearTimeout(timeoutId); submitBtn.disabled = false;
        }
    }

    // [ä¿®æ­£] callAI æ”¯æ´ overrideModel å’Œ overrideKey (è®“ PDF å·¥å…·ç®±å¯å¼·åˆ¶ä½¿ç”¨ Gemini)
    async function callAI(provider, text, fileBase64, mimeType, signal, overrideModel = null, overrideKey = null) {
        // è‹¥æœ‰å‚³å…¥ overrideKey å‰‡å„ªå…ˆä½¿ç”¨ï¼Œå¦å‰‡æŠ“ä»‹é¢ä¸Šçš„
        const apiKey = overrideKey || document.getElementById('api-key').value;
        const prompt = document.getElementById('system-prompt').value;
        // è‹¥æœ‰å‚³å…¥ overrideModel å‰‡å„ªå…ˆä½¿ç”¨
        const model = overrideModel || currentActiveModelId;

        if (!apiKey) throw new Error("è«‹è¼¸å…¥ API Key");

        let body = {};
        let url = "";
        let headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

        if (provider === 'gemini') {
            url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            delete headers['Authorization']; 
            const parts = [];
            if (fileBase64) parts.push({ inline_data: { mime_type: mimeType, data: fileBase64 } });
            parts.push({ text: text });
            
            // ä¿®æ­£ï¼šç‚ºäº†åŒæ™‚æ”¯æ´ Tool å’Œä¸€èˆ¬å°è©±ï¼Œæˆ‘å€‘æª¢æŸ¥ chatHistory æ˜¯å¦ç‚ºç©º
            let contents = [];
            if (chatHistory.length > 0) {
                 // é€™è£¡åªç°¡å–®å¯¦ä½œï¼šè‹¥æœ‰ historyï¼Œå‡è¨­é€™æ˜¯å°è©±æ¨¡å¼ï¼Œç›´æ¥ append
                 // ä½†ç‚ºäº†ç°¡åŒ–ï¼Œè‹¥ overrideModel å­˜åœ¨ (ä»£è¡¨æ˜¯ Tool æ¨¡å¼)ï¼Œæˆ‘å€‘ä¸ä½¿ç”¨ history
                 if (overrideModel) {
                     contents.push({ role: "user", parts: parts });
                 } else {
                     // é€™è£¡æ‡‰è©²è¦è™•ç† chatHistory è½‰ Gemini æ ¼å¼ï¼Œä½†ç‚ºäº†æ¥µç°¡ç‰ˆï¼Œæš«æ™‚å¿½ç•¥å®Œæ•´æ­·å²è½‰åˆ¶
                     // å¯¦å‹™ä¸Šå»ºè­°ä½¿ç”¨æœ€æ–°çš„ contents
                     contents.push({ role: "user", parts: parts });
                 }
            } else {
                 contents.push({ role: "user", parts: parts });
            }

            body = { system_instruction: { parts: [{ text: prompt }] }, contents: contents };

        } else {
            // OpenAI / OpenRouter ç­‰
            if (provider === 'openrouter') {
                url = "https://openrouter.ai/api/v1/chat/completions";
                headers['HTTP-Referer'] = window.location.href; headers['X-Title'] = 'AI Assistant';
                if (document.getElementById('openrouter-web-search').checked) body.plugins = [{ id: "web" }];
            } else if (provider === 'openai') url = "https://api.openai.com/v1/chat/completions";
            else if (provider === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";
            else if (provider === 'groq') url = "https://api.groq.com/openai/v1/chat/completions";

            let messages = [{ role: "system", content: prompt }];
            let content = text;
            if (fileBase64) content = [{ type: "text", text: text }, { type: "image_url", image_url: { url: `data:${mimeType};base64,${fileBase64}` } }];
            messages.push({ role: "user", content: content });

            body = { ...body, model: model, messages: messages, temperature: 0.3 };
        }

        const res = await fetch(url, { method: 'POST', headers: headers, body: JSON.stringify(body), signal: signal });
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        
        if (provider === 'gemini') return data.candidates?.[0]?.content?.parts?.[0]?.text || "ç„¡å›æ‡‰";
        return data.choices?.[0]?.message?.content || "ç„¡å›æ‡‰";
    }
</script>
</body>
</html>
