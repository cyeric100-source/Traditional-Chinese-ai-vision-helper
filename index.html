<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¦–éšœåŠ©ç† (æ¥µç°¡å…¨èƒ½ç‰ˆ - 2025 å…¨æ–‡ç¿»è­¯ç‰ˆ)</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.2/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>

    <!-- ã€æ ¸å¿ƒã€‘PDF.js v5.4.449 : CDN å„ªå…ˆ + Blob Fallback é›™é‡è¼‰å…¥æ©Ÿåˆ¶ -->
    <script type="module">
        import * as pdfjsLib from 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4.449/build/pdf.min.mjs';
        
        window.pdfjsLib = pdfjsLib;
        
        // å®šç¾© Worker URL
        const WORKER_URL = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4.449/build/pdf.worker.min.mjs';

        // åˆå§‹åŒ– Worker (Blob å„ªå…ˆç­–ç•¥)
        (async function initPdfWorker() {
            try {
                const response = await fetch(WORKER_URL);
                if (!response.ok) throw new Error("Worker fetch failed");
                const workerScript = await response.text();
                const blob = new Blob([workerScript], { type: "application/javascript" });
                pdfjsLib.GlobalWorkerOptions.workerSrc = URL.createObjectURL(blob);
                console.log("PDF Worker loaded via Blob (Safe Mode).");
            } catch (e) {
                console.warn("Blob load failed, falling back to direct CDN URL.", e);
                pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;
            }
            window.dispatchEvent(new Event('pdfjs-loaded'));
        })();
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;      /* é»ƒè‰²é«˜äº® */
            --user-header-color: #0088ff; /* ç”¨æˆ¶æ¨™é¡Œè‰² */
            --ai-header-color: #FFFF00;   /* AI æ¨™é¡Œè‰² */
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
            --tool-bg: #112233;
            --active-tab-bg: #004488;
            --active-tab-text: #ffffff;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.2rem; line-height: 1.6;
            padding-top: 60px;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .message-area, #system-prompt, #user-input, input {
            -webkit-user-select: text;
            user-select: text;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 10px 10px 450px 10px;
        }

        .app-title { 
            font-size: 1.5rem; text-align: center; margin: 10px 0; color: #ccc; font-weight: bold;
        }
        
        details h2 { 
            font-size: 1.4rem; color: #ccc; 
            border-bottom: 2px solid #333; padding-bottom: 5px; margin-top: 10px; 
            display: inline-block;
        }

        input, select, textarea {
            width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px;
            background: var(--input-bg); border: 2px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px; box-sizing: border-box;
        }

        #system-prompt {
            min-height: 300px;
            resize: vertical;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.4;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-top: none;
        }
        
        *:focus-visible { outline: 4px solid var(--accent-color) !important; }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            border: 2px solid #fff; padding: 12px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-top: 5px; cursor: pointer; touch-action: manipulation;
        }
        button:disabled { filter: grayscale(100%); opacity: 0.7; cursor: not-allowed; }
        button.secondary { background-color: #333; color: #fff; border-color: #777; }
        
        button.mini-copy-btn {
            background-color: #333; color: #fff; border: 1px solid #777;
            padding: 6px 12px; font-size: 0.9rem; margin-top: 10px;
            width: auto; display: inline-block;
        }
        button.mini-copy-btn:hover { background-color: #555; }
        
        button.danger {
            background-color: #550000; color: #ffcccc; border-color: #ff4444;
        }

        button.tool-btn {
            background-color: #0066cc; color: white; border: 2px solid #44aaff;
        }
        
        button.recording {
            background-color: #ff3333 !important; 
            color: #ffffff !important; 
            border-color: #ffaaaa !important;
            transform: scale(0.98);
            box-shadow: inset 0 0 10px #000;
        }
        
        /* ä»»å‹™æŒ‡æ´¾æŒ‰éˆ•ç¾¤çµ„ */
        .assign-btn-group {
            display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;
        }
        .assign-btn-group button {
            flex: 1; font-size: 1rem; padding: 8px; margin-top: 0; min-width: 120px;
            background-color: #224466; color: #fff; border: 1px solid #4488cc;
        }
        .assign-btn-group button.reset {
            background-color: #442222; border-color: #cc6666;
        }

        #config-status-display {
            background: #1a1a1a; border: 1px solid #444; padding: 10px; 
            border-radius: 6px; margin-bottom: 15px; font-size: 0.95rem; color: #aaa;
        }
        #config-status-display strong { color: #88ccff; }
        #config-status-display .highlight { color: var(--accent-color); }

        /* ç³»çµ±æŒ‡ä»¤æ¨™ç±¤é æ¨£å¼ */
        .prompt-tabs {
            display: flex; gap: 2px; margin-top: 15px;
        }
        .prompt-tabs button {
            flex: 1; border-bottom-left-radius: 0; border-bottom-right-radius: 0;
            margin-top: 0; border-bottom: none; background: #333; color: #aaa;
            font-size: 1rem; padding: 10px 5px;
        }
        .prompt-tabs button.active {
            background: var(--active-tab-bg); color: var(--active-tab-text);
            border-color: #fff; font-weight: bold;
        }

        details { border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-bottom: 10px; background: #111; }
        summary { cursor: pointer; padding: 5px; }
        
        .pdf-tool-group {
            background: var(--tool-bg); border: 2px solid #005588;
        }
        .pdf-tool-group h2 { color: #88ccff; border-bottom-color: #005588; }
        
        .message-area { min-height: 100px; padding-bottom: 20px; }
        
        .message {
            background: #111; padding: 15px; margin-bottom: 25px;
            border-left: 5px solid var(--border-color);
            overflow-wrap: break-word; word-wrap: break-word; word-break: break-word;
        }
        .message:focus { outline: none; border-left: 8px solid var(--accent-color); background: #222; }

        .message h1.msg-heading {
            font-size: 1.4rem; margin: 0 0 10px 0; padding-bottom: 5px;
            border-bottom: 1px dashed #444; line-height: 1.3;
        }

        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.user h1.msg-heading { color: var(--user-header-color); }
        
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message.assistant h1.msg-heading { color: var(--ai-header-color); }

        .message.error { border-left-color: #ff0000; background: #330000; }
        .message.error h1.msg-heading { color: #ff5555; }

        .markdown-body { line-height: 1.7; overflow-wrap: break-word; }
        .markdown-body h1, .markdown-body h2 { color: #88CCFF; border-bottom: none; margin-top: 1.5em; }
        .markdown-body p { margin-bottom: 10px; white-space: pre-wrap; } 
        .markdown-body pre { 
            background: #222; padding: 10px; overflow-x: auto; 
            border: 1px solid #444; white-space: pre; 
        }
        .markdown-body code { background: #333; padding: 2px 4px; word-break: break-all; }

        .controls-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #000; border-top: 3px solid var(--accent-color);
            padding: 10px; z-index: 100;
        }

        .row { display: flex; gap: 10px; margin-bottom: 8px; align-items: flex-end; }
        
        .check-btn {
            display: flex; align-items: center; justify-content: center;
            background: #222; border: 1px solid #555; color: #fff;
            padding: 10px; border-radius: 6px; flex: 1;
            cursor: pointer; margin-top: 5px;
            height: auto; min-height: 52px;
        }
        .check-btn input { width: 20px; height: 20px; margin: 0 8px 0 0; }

        #user-input {
            margin: 0; min-height: 80px; max-height: 200px;
            resize: vertical; overflow-y: auto; flex: 1;
            transition: border-color 0.2s;
        }
        #user-input.dragover { border-color: var(--accent-color) !important; background-color: #222; }

        #status-bar {
            position: fixed; top: 0; left: 0; right: 0;
            background: var(--status-bg); color: #fff;
            padding: 10px; text-align: center;
            font-weight: bold; font-size: 1.1rem;
            z-index: 2000; border-bottom: 2px solid var(--border-color);
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; border-bottom-color: #00ff00; }
        #status-bar.busy { background: #664400; border-bottom-color: #ffff00; }
        #status-bar.error { background: #660000; border-bottom-color: #ff0000; }
        #status-bar.recording { background: #aa0000; border-bottom-color: #ff0000; animation: pulse-status 1s infinite; }
        
        @keyframes pulse-status {
             0% { background-color: #aa0000; }
             50% { background-color: #ff0000; }
             100% { background-color: #aa0000; }
        }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        #custom-model-wrapper { margin-top: -5px; margin-bottom: 10px; }
        .settings-subsection { border: 1px solid #444; padding: 10px; border-radius: 6px; margin: 10px 0; background: #222; }
        .settings-subsection h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent-color); }
        .export-actions { margin-bottom: 20px; display: flex; gap: 10px; }
    </style>
</head>
<body>

<!-- ç‹€æ…‹åˆ— -->
<div id="status-bar" role="status" aria-live="polite" aria-atomic="true" tabindex="-1">ç³»çµ±åˆå§‹åŒ–ä¸­ (è«‹ç¨å€™)...</div>

<div class="container">
    <h1 class="app-title">AI è¦–éšœåŠ©ç† (æ¥µç°¡å…¨èƒ½ç‰ˆ - 2025 å…¨æ–‡ç¿»è­¯ç‰ˆ)</h1>

    <!-- è¨­å®šå€ -->
    <details id="settings-area">
        <summary role="button" aria-expanded="false" id="settings-summary" aria-keyshortcuts="Alt+Shift+S">
            <h2>è¨­å®š (Alt+Shift+S)</h2>
        </summary>
        
        <div style="margin-top: 15px;">
            <label for="provider-select">ä¸»è¦ AI æœå‹™å•†:</label>
            <select id="provider-select" onchange="handleProviderChange()">
                <option value="gemini">Google Gemini (æ¨è–¦)</option>
                <option value="openrouter">OpenRouter (å¤šæ¨¡å‹ - æ”¯æ´ CORS)</option>
                <option value="mistral">Mistral AI</option>
                <option value="openai">OpenAI (GPT)</option>
                <option value="groq">Groq</option>
                <option value="perplexity">Perplexity</option>
            </select>

            <label for="api-key">ä¸»è¦ API Key:</label>
            <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
            
            <label for="model-filter-input">ç¯©é¸æ¨¡å‹ (å³æ™‚æœå°‹):</label>
            <input type="text" id="model-filter-input" placeholder="è¼¸å…¥é—œéµå­—ç¯©é¸ (å¦‚: gemini, latest)..." oninput="handleModelFilter()">

            <label for="model-select">æ¨¡å‹é¸æ“‡ (2025æœ€æ–°):</label>
            <div class="row" style="margin-bottom: 10px;">
                <select id="model-select" style="margin-bottom:0;" onchange="handleModelSelectChange()"></select>
                <button type="button" id="refresh-btn" class="secondary" style="width: auto; margin-top:0;" onclick="fetchOnlineModels()" title="å¾ç¶²è·¯æ›´æ–°æ¨¡å‹æ¸…å–®">æ›´æ–°</button>
            </div>
            
            <div id="custom-model-wrapper" class="hidden">
                <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
            </div>

            <!-- ä»»å‹™æŒ‡æ´¾ -->
            <div class="settings-subsection">
                <h3>åˆ†å·¥è¨­å®š (Task Assignment)</h3>
                <p style="margin:0 0 10px 0; font-size:0.9rem; color:#ccc;">
                    èªªæ˜ï¼šæ‚¨å¯ä»¥åœ¨ä¸Šæ–¹é¸æ“‡ä¸åŒçš„ AI èˆ‡æ¨¡å‹ï¼Œç„¶å¾ŒæŒ‰ä¸‹æŒ‰éˆ•å°‡å…¶æŒ‡å®šç‚ºç‰¹å®šä»»å‹™å°ˆç”¨ã€‚
                </p>
                <div class="assign-btn-group">
                    <button type="button" onclick="setSpecificConfig('ocr')">è¨­ç‚º OCR PDF å°ˆç”¨</button>
                    <button type="button" onclick="setSpecificConfig('translate')">è¨­ç‚º ç¿»è­¯ PDF å°ˆç”¨</button>
                    <button type="button" class="reset" onclick="clearSpecificConfigs()">é‡ç½®ç‚ºè·Ÿéš¨ä¸»è¦è¨­å®š</button>
                </div>
                <div id="config-status-display" aria-live="polite">
                    ç›®å‰è¨­å®šè¼‰å…¥ä¸­...
                </div>
            </div>

            <div id="openrouter-settings" class="hidden settings-subsection">
                <h3>OpenRouter æœå°‹è¨­å®š</h3>
                <label class="check-btn">
                    <input type="checkbox" id="openrouter-web-search">
                    <span>å•Ÿç”¨è¯ç¶²æœå°‹ (Web Search)</span>
                </label>
            </div>
            
            <label class="check-btn" style="flex:none; width:auto; margin-bottom: 10px;">
                <input type="checkbox" id="enter-to-send" checked>
                <span>æŒ‰ Enter éµå‚³é€ (å–æ¶ˆå‹¾é¸å‰‡ Enter ç‚ºæ›è¡Œ)</span>
            </label>

            <div class="settings-subsection">
                <h3>èªéŸ³è¼¸å…¥è¨­å®š</h3>
                <label for="voice-engine">èªéŸ³è¾¨è­˜å¼•æ“:</label>
                <select id="voice-engine" onchange="saveVoiceSettings()">
                    <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»ï¼Œå°è¬›æ©Ÿæ¨¡å¼)</option>
                    <option value="openai">OpenAI Whisper (é«˜æº–ç¢ºï¼Œéœ€ä»˜è²»)</option>
                    <option value="groq">Groq Whisper (æ¥µé€Ÿï¼Œéœ€ Key)</option>
                </select>
                <label for="voice-api-key">èªéŸ³è¾¨è­˜å°ˆç”¨ API Key (é¸å¡«):</label>
                <input type="password" id="voice-api-key" placeholder="è‹¥ç•™ç©ºï¼Œå°‡å˜—è©¦ä½¿ç”¨ä¸»è¦ API Key" autocomplete="off" onchange="saveVoiceSettings()">
            </div>

            <label for="timeout-setting">å›æ‡‰é€¾æ™‚ (ç§’):</label>
            <input type="number" id="timeout-setting" value="120" min="5" step="5">

            <!-- ç³»çµ±æŒ‡ä»¤ç·¨è¼¯å™¨ (Tab ä»‹é¢) -->
            <label style="margin-top: 15px; display:block; font-weight:bold;">ç³»çµ±æŒ‡ä»¤ (System Prompts):</label>
            <div class="prompt-tabs">
                <button type="button" id="tab-chat" class="active" onclick="switchPromptEditor('chat')">ç·¨è¼¯: ä¸€èˆ¬å°è©±æŒ‡ä»¤</button>
                <button type="button" id="tab-ocr" onclick="switchPromptEditor('ocr')">ç·¨è¼¯: OCR å°ˆç”¨æŒ‡ä»¤</button>
                <button type="button" id="tab-translate" onclick="switchPromptEditor('translate')">ç·¨è¼¯: ç¿»è­¯å°ˆç”¨æŒ‡ä»¤</button>
            </div>
            <textarea id="system-prompt" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>

            <div class="row">
                <button type="button" onclick="saveSettings()">å„²å­˜è¨­å®š</button>
                <button type="button" onclick="restoreDefaults()" class="secondary">æ¢å¾©é è¨­å€¼</button>
                <button type="button" onclick="showHelp()" class="secondary" style="background:#004488; color:white;">åŠŸèƒ½èªªæ˜</button>
            </div>
        </div>
    </details>

    <!-- PDF å®Œæ•´é–±è®€å·¥å…·ç®± -->
    <details class="pdf-tool-group" open>
        <summary role="button" aria-expanded="true">
            <h2>PDF æ™ºèƒ½é–±è®€å·¥å…·ç®± (OCR & ç¿»è­¯)</h2>
        </summary>
        <div style="margin-top: 15px;">
            <input type="file" id="pdf-tool-input" class="visually-hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">

            <!-- æ§åˆ¶é … A -->
            <button type="button" id="pdf-start-btn" class="tool-btn" onclick="document.getElementById('pdf-tool-input').click()" disabled>
                ğŸ“„ PDF å®Œæ•´é–±è®€ (è¼‰å…¥ä¸­...)
            </button>
            <small style="display:block; margin: 5px 0 15px 0; color:#ccc;">
                * èªªæ˜ï¼šå„ªå…ˆä½¿ç”¨æœ¬æ©Ÿæå–ã€‚è‹¥å¤±æ•—ï¼Œå°‡è‡ªå‹•è½‰æˆåœ–ç‰‡å‚³çµ¦ AI (OCR)ã€‚
            </small>

            <div class="row">
                <!-- æ§åˆ¶é … B -->
                <label class="check-btn">
                    <input type="checkbox" id="pdf-always-ai">
                    <span>ç¸½æ˜¯å°‡ PDF å‚³çµ¦ AI (è·³éæœ¬æ©Ÿæå–)</span>
                </label>

                <!-- æ§åˆ¶é … C -->
                <label class="check-btn">
                    <input type="checkbox" id="pdf-translate">
                    <span>å¼·åˆ¶ç¿»è­¯æˆç¹é«”ä¸­æ–‡ (ä¸åˆªæ¸›å…§å®¹)</span>
                </label>
            </div>
        </div>
    </details>

    <!-- çµæœå€ -->
    <main role="main">
        <div id="chat-output" class="message-area"></div>
        
        <div class="export-actions">
            <button type="button" id="copy-btn" class="secondary hidden" onclick="copyResult()" aria-keyshortcuts="Alt+Shift+C" style="flex:1;">
                è¤‡è£½ (Alt+Shift+C)
            </button>
            <button type="button" id="export-txt-btn" class="secondary hidden" onclick="exportChat('txt')" aria-keyshortcuts="Alt+Shift+T" style="flex:1;">
                åŒ¯å‡º TXT (Alt+Shift+T)
            </button>
            <button type="button" id="export-html-btn" class="secondary hidden" onclick="exportChat('html')" aria-keyshortcuts="Alt+Shift+H" style="flex:1;">
                åŒ¯å‡º HTML (Alt+Shift+H)
            </button>
        </div>
    </main>
</div>

<!-- æ§åˆ¶å€ -->
<footer class="controls-wrapper" role="region" aria-label="æ“ä½œå€">
    <form onsubmit="handleSubmit(event)">
        <div class="row">
            <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
            
            <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()" aria-keyshortcuts="Alt+Shift+U" style="flex:1;">
                é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)
            </button>
            
            <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()" aria-keyshortcuts="Alt+Shift+N" style="flex:1;">
                æ¸…é™¤å°è©± (Alt+Shift+N)
            </button>

            <label class="check-btn" style="flex:1;">
                <input type="checkbox" id="pause-send" aria-keyshortcuts="Alt+Shift+P">
                <span>æš«åœå‚³é€ (Alt+Shift+P)</span>
            </label>
        </div>
        
        <div class="row">
            <button type="button" id="voice-btn" class="secondary" aria-keyshortcuts="Alt+Shift+V" style="width: auto; padding: 0 15px; height: 80px; margin:0; font-size: 1.2rem;" title="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾èªªè©±)" aria-label="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾èªªè©±)">
                æŒ‰ä½èªªè©±
            </button>
            
            <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯... (å¯æ‹–æ”¾æª”æ¡ˆæˆ– Ctrl+V)" aria-keyshortcuts="Alt+Shift+I" autocomplete="off" rows="3" aria-label="è¼¸å…¥è¨Šæ¯å€"></textarea>
            
            <button type="submit" id="submit-btn" aria-keyshortcuts="Alt+Shift+K" style="width: 80px; height: 80px; margin:0;" title="ç™¼é€ (Alt+Shift+K)">å‚³é€</button>
        </div>
    </form>
</footer>

<script>
    // ç›£è½ PDF æ ¸å¿ƒè¼‰å…¥äº‹ä»¶
    window.addEventListener('pdfjs-loaded', () => {
        const btn = document.getElementById('pdf-start-btn');
        btn.innerText = "ğŸ“„ PDF å®Œæ•´é–±è®€ (æ™ºèƒ½åµæ¸¬å•Ÿå‹•)";
        btn.disabled = false;
        showReadyStatus();
    });

    window.onerror = function(message, source, lineno, colno, error) {
        const statusBar = document.getElementById('status-bar');
        if (statusBar) {
            statusBar.innerText = `ç™¼ç”ŸéŒ¯èª¤: ${message}`;
            statusBar.className = 'error';
            statusBar.setAttribute('aria-live', 'assertive');
        }
        console.error("Global Error:", message, error);
    };

    const DEFAULT_CHAT_PROMPT = `# è§’è‰²è¨­å®š (Persona)
ä½ æ˜¯ä¸€ä½å°ˆç‚ºé¦™æ¸¯è¦–éšœäººå£«æœå‹™çš„é ‚å°– AI è¦–è¦ºèˆ‡è³‡è¨ŠåŠ©ç†ã€‚ä½ çš„æ ¸å¿ƒè·è²¬æ˜¯æˆç‚ºç”¨æˆ¶çš„çœ¼ç›èˆ‡å¤§è…¦å»¶ä¼¸ã€‚

# å…¨åŸŸè¦å‰‡ (Global Rules)
1. **èªè¨€**ï¼šç¹é«”ä¸­æ–‡ï¼ˆé¦™æ¸¯æ…£ç”¨ï¼‰ã€‚
2. **ç„¡éšœç¤™æ ¼å¼**ï¼šä½¿ç”¨ Markdown æ¨™é¡Œ (#) èˆ‡æ¸…å–® (-)ï¼Œä¸ä½¿ç”¨å¹²æ“¾æœ—è®€çš„ç¬¦è™Ÿã€‚
3. **ç²¾ç°¡**ï¼šé‡é»ç½®å‰ï¼Œé¿å…å†—é•·ã€‚
`;

    const DEFAULT_OCR_PROMPT = `
# SYSTEM ROLE
You are a state-of-the-art Optical Character Recognition (OCR) engine, NOT an AI assistant. Your sole purpose is to convert image pixels into exact text strings.

# TASK
Transcribe EVERY single visible character from the provided document image(s) into text.

# STRICT EXECUTION RULES (ZERO TOLERANCE FOR OMISSION)
1. **VERBATIM TRANSCRIPTION**: Output the text EXACTLY as it appears in the image.
   - Do NOT correct spelling or grammar errors.
   - Do NOT summarize, abbreviate, or paraphrase any content.
   - Do NOT skip headers, footers, page numbers, margin notes, or legal disclaimers.
   - Do NOT add conversational fillers like "Here is the text" or "Image content:".

2. **MULTILINGUAL HANDLING**: The document may contain Mixed Languages (Traditional/Simplified Chinese, English, Japanese, French, Italian, Portuguese, Korean, German, Spanish, Dutch, Russian).
   - Recognize and transcribe all scripts accurately.
   - Do NOT translate during the OCR phase. Keep the original language of the text.

3. **LAYOUT & FORMATTING**:
   - Use Markdown to preserve the visual structure (headers with #, lists with -, bold with **).
   - If there is a table, transcribe it as a Markdown table.
   - Represent illegible or stamp-covered text as \`[ILLEGIBLE]\`.

# OUTPUT FORMAT
Return ONLY the raw string of the transcribed text.
`;

    const DEFAULT_TRANSLATE_PROMPT = `
# SYSTEM ROLE
You are a professional textual translator specializing in localization for Traditional Chinese (Hong Kong/Taiwan usage). You are NOT a summarizer.

# TASK
Translate the provided source content FULLY and ACCURATELY into fluent, natural Traditional Chinese (ç¹é«”ä¸­æ–‡).

# STRICT TRANSLATION PROTOCOLS
1. **100% COMPLETENESS**: 
   - Translate every single sentence, clause, number, and punctuation mark.
   - Do NOT summarize, condense, or omit any paragraph, no matter how repetitive it seems.
   - Preserve all headers, footers, and page numbers in the translation.

2. **TONE & STYLE**:
   - Convert foreign idioms into natural Hong Kong/Taiwanese expressions (e.g., "bus" -> "å·´å£«/å…¬è»Š", "software" -> "è»Ÿä»¶/è»Ÿé«”").
   - Maintain the formality of the original document (e.g., Legal, Medical, or Casual).

3. **FORMATTING PRESERVATION**:
   - Keep the original Markdown structure (paragraphs, lists, tables) exactly as provided.
   - Do NOT output the original English/Source text unless explicitly asked. Output ONLY the translated result.

# OUTPUT REQUIREMENT
Output purely the translated text. Do not add introductions like "Here is the translation".
`;

    const PROMPT_VERSION_KEY = "prompt_version_2025_fixed_v26_fullcontext";
    
    const PROVIDERS = {
        gemini: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gemini-2.5-flash", canFetch: true, listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}", models: ["gemini-2.5-flash", "gemini-1.5-flash", "gemini-1.5-pro"] },
        openrouter: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "openai/gpt-4o", canFetch: true, listUrl: "https://openrouter.ai/api/v1/models", models: ["openai/gpt-4o", "google/gemini-2.5-flash", "google/gemini-flash-1.5", "anthropic/claude-3.5-sonnet"] },
        mistral: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "mistral-large-latest", canFetch: true, listUrl: "https://api.mistral.ai/v1/models", models: ["mistral-large-latest"] },
        openai: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gpt-4o", canFetch: true, listUrl: "https://api.openai.com/v1/models", models: ["gpt-4o"] },
        groq: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "llama-3.3-70b-versatile", canFetch: true, listUrl: "https://api.groq.com/openai/v1/models", models: ["llama-3.3-70b-versatile"] },
        perplexity: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "sonar-pro", canFetch: false, models: ["sonar-pro"] }
    };

    let currentActiveModelId = "";
    let selectedFile = null;
    let recognition = null; 
    let mediaRecorder = null;
    let audioChunks = [];
    let chatHistory = [];
    let audioContext = null;
    let allCurrentModels = [];
    let isVoiceRecording = false;
    let specificConfigs = { ocr: null, translate: null };
    let memoryPrompts = { chat: "", ocr: "", translate: "" };
    let currentEditingMode = 'chat'; 

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function smartMergeLines(rawText) {
        if (!rawText) return "";
        const lines = rawText.split(/\r?\n/);
        let processedText = "";
        const isCJK = (c) => /[\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\uFF00-\uFFEF]/.test(c);

        for (let i = 0; i < lines.length; i++) {
            let currLine = lines[i].trim();
            if (currLine.length === 0) { processedText += "\n\n"; continue; }
            if (i < lines.length - 1) {
                let nextLine = lines[i + 1].trim();
                if (nextLine.length === 0) { processedText += currLine + "\n"; continue; }
                const lastChar = currLine.slice(-1);
                const nextChar = nextLine.charAt(0);
                const isSentenceEnd = /[.ã€‚ï¼ï¼Ÿ?!:;ï¼šï¼›]$/.test(currLine);
                const isHeaderOrList = /^#/.test(currLine) || /^[-*] /.test(currLine) || /^#/.test(nextLine) || /^[-*] /.test(nextLine);

                if (isSentenceEnd || isHeaderOrList) { processedText += currLine + "\n"; } 
                else {
                    if (lastChar === '-' && /[a-zA-Z]/.test(currLine.slice(-2, -1))) { processedText += currLine.slice(0, -1); } 
                    else if (isCJK(lastChar) && isCJK(nextChar)) { processedText += currLine; } 
                    else { processedText += currLine + " "; }
                }
            } else { processedText += currLine + "\n"; }
        }
        return processedText.replace(/\n{3,}/g, "\n\n").trim();
    }

    function unlockAudioContext() {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                document.removeEventListener('click', unlockAudioContext);
                document.removeEventListener('touchstart', unlockAudioContext);
            });
        }
    }
    document.addEventListener('click', unlockAudioContext);
    document.addEventListener('touchstart', unlockAudioContext);
    document.addEventListener('keydown', handleGlobalShortcuts);

    function initVoiceButtonEvents() {
        const btn = document.getElementById('voice-btn');
        if (!btn) return;
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); startVoiceRecording(); }, {passive: false});
        btn.addEventListener('touchend', (e) => { e.preventDefault(); stopVoiceRecording(); });
        btn.addEventListener('mousedown', (e) => { startVoiceRecording(); });
        btn.addEventListener('mouseup', (e) => { stopVoiceRecording(); });
        btn.addEventListener('mouseleave', (e) => { if(isVoiceRecording) stopVoiceRecording(); });
        btn.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    function handleGlobalShortcuts(e) {
        if (!e.altKey || !e.shiftKey) return;
        const key = e.key.toLowerCase();
        
        if (key === 'v') {
            e.preventDefault();
            if (isVoiceRecording) stopVoiceRecording();
            else startVoiceRecording();
            return;
        }

        const actions = {
            's': { id: 'settings-summary', type: 'click' },
            'c': { id: 'copy-btn', type: 'click' },
            't': { id: 'export-txt-btn', type: 'click' },
            'h': { id: 'export-html-btn', type: 'click' },
            'u': { id: 'upload-btn', type: 'click' },
            'n': { id: 'new-chat-btn', type: 'click' },
            'p': { id: 'pause-send', type: 'click' },
            'k': { id: 'submit-btn', type: 'click' },
            'i': { id: 'user-input', type: 'focus' },
            'r': { selector: '.latest-copy-btn', type: 'click' }
        };

        if (actions[key]) {
            e.preventDefault();
            let target;
            if (actions[key].id) target = document.getElementById(actions[key].id);
            else if (actions[key].selector) target = document.querySelector(actions[key].selector);
            if (target) {
                if (actions[key].type === 'click') target.click();
                else if (actions[key].type === 'focus') target.focus();
            }
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        try {
            if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => localStorage.removeItem(`${p}_prompt`));
                localStorage.setItem(PROMPT_VERSION_KEY, 'true');
            }

            const savedProvider = localStorage.getItem('provider');
            const settingsDetails = document.getElementById('settings-area');
            const savedTimeout = localStorage.getItem('timeout_setting');
            if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;
            
            document.getElementById('openrouter-web-search').checked = (localStorage.getItem('openrouter_web_search') === 'true');
            const savedVoiceEngine = localStorage.getItem('voice_engine');
            if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
            const savedVoiceKey = localStorage.getItem('voice_api_key');
            if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;
            
            const savedEnter = localStorage.getItem('enter_to_send');
            document.getElementById('enter-to-send').checked = (savedEnter === null || savedEnter === 'true');

            const savedSpecifics = localStorage.getItem('specific_configs');
            if (savedSpecifics) {
                specificConfigs = JSON.parse(savedSpecifics);
            }
            updateConfigStatusDisplay();

            memoryPrompts.ocr = localStorage.getItem('custom_prompt_ocr') || DEFAULT_OCR_PROMPT;
            memoryPrompts.translate = localStorage.getItem('custom_prompt_translate') || DEFAULT_TRANSLATE_PROMPT;

            if (savedProvider && PROVIDERS[savedProvider]) {
                document.getElementById('provider-select').value = savedProvider;
                settingsDetails.open = false; 
            } else {
                document.getElementById('provider-select').value = 'gemini'; 
                settingsDetails.open = true; 
            }
            
            handleProviderChange(false); 
            initVoiceSystem();
            initPasteImage();
            initDragAndDrop();
            initEnterKey();
            initVoiceButtonEvents();

        } catch (e) {
            updateStatusBar("åˆå§‹åŒ–éŒ¯èª¤: " + e.message, "error");
        }
    });

    function switchPromptEditor(mode) {
        const textarea = document.getElementById('system-prompt');
        memoryPrompts[currentEditingMode] = textarea.value;
        currentEditingMode = mode;
        textarea.value = memoryPrompts[mode];
        document.getElementById('tab-chat').classList.toggle('active', mode === 'chat');
        document.getElementById('tab-ocr').classList.toggle('active', mode === 'ocr');
        document.getElementById('tab-translate').classList.toggle('active', mode === 'translate');
    }

    function setSpecificConfig(type) {
        const provider = document.getElementById('provider-select').value;
        const model = currentActiveModelId;
        
        specificConfigs[type] = { provider, model };
        localStorage.setItem('specific_configs', JSON.stringify(specificConfigs));
        
        const currentKey = document.getElementById('api-key').value;
        if (currentKey) {
            localStorage.setItem(`${provider}_key`, currentKey.trim());
        }
        
        updateConfigStatusDisplay();
        showTransientStatus(`å·²å°‡ç•¶å‰è¨­å®šå¥—ç”¨æ–¼: ${type === 'ocr' ? 'OCR' : 'ç¿»è­¯'}`);
    }

    function clearSpecificConfigs() {
        specificConfigs = { ocr: null, translate: null };
        localStorage.removeItem('specific_configs');
        updateConfigStatusDisplay();
        showTransientStatus("å·²æ¸…é™¤å°ˆç”¨è¨­å®šï¼Œå°‡è·Ÿéš¨ä¸»è¦è¨­å®š");
    }

    function updateConfigStatusDisplay() {
        const display = document.getElementById('config-status-display');
        let html = "<strong>ç›®å‰é…ç½®ï¼š</strong><br>";
        
        if (specificConfigs.ocr) {
            html += `â€¢ OCR PDF: <span class="highlight">${specificConfigs.ocr.provider} / ${specificConfigs.ocr.model}</span><br>`;
        } else {
            html += `â€¢ OCR PDF: è·Ÿéš¨ä¸»è¦è¨­å®š<br>`;
        }
        
        if (specificConfigs.translate) {
            html += `â€¢ ç¿»è­¯ PDF: <span class="highlight">${specificConfigs.translate.provider} / ${specificConfigs.translate.model}</span>`;
        } else {
            html += `â€¢ ç¿»è­¯ PDF: è·Ÿéš¨ä¸»è¦è¨­å®š`;
        }
        
        display.innerHTML = html;
    }

    function playAudioCue(type) {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        const now = audioContext.currentTime;
        
        if (type === 'start') { 
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(880, now); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1); 
            if (navigator.vibrate) navigator.vibrate(50); 
        } 
        else if (type === 'success') { 
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, now); oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.2); 
        } 
        else if (type === 'error') { 
            oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(150, now); gainNode.gain.setValueAtTime(0.15, now); oscillator.start(now); oscillator.stop(now + 0.4); 
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]); 
        }
        else if (type === 'abort') {
            oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(400, now); oscillator.frequency.linearRampToValueAtTime(200, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1);
            const osc2 = audioContext.createOscillator(); const gain2 = audioContext.createGain(); osc2.connect(gain2); gain2.connect(audioContext.destination); osc2.type = 'triangle'; osc2.frequency.setValueAtTime(400, now + 0.15); osc2.frequency.linearRampToValueAtTime(200, now + 0.25); gain2.gain.setValueAtTime(0.1, now + 0.15); osc2.start(now + 0.15); osc2.stop(now + 0.25);
            if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
        }
    }

    function resetConversation() {
        chatHistory = []; 
        document.getElementById('chat-output').innerHTML = ""; 
        document.getElementById('user-input').value = "";
        selectedFile = null;
        document.getElementById('upload-btn').innerText = "é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)";
        document.getElementById('file-input').value = "";
        toggleExportButtons(false);
        showTransientStatus("å°è©±ç´€éŒ„å·²æ¸…é™¤ (æ–°å°è©±)", "info");
    }

    function handlePDFToolFileSelect() {
        const input = document.getElementById('pdf-tool-input');
        if (input.files.length > 0) {
            processPDFTool(input.files[0]);
            document.getElementById('status-bar').focus(); 
        }
        input.value = ""; 
    }

    async function processPDFTool(file) {
        if (typeof window.pdfjsLib === 'undefined') {
            alert("PDF æ ¸å¿ƒæ­£åœ¨è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™å†è©¦ã€‚");
            return;
        }

        if (!file || file.type !== 'application/pdf') { alert("è«‹é¸æ“‡ PDF æª”æ¡ˆ"); return; }
        resetConversation(); playAudioCue('start');
        
        const alwaysAI = document.getElementById('pdf-always-ai').checked;
        const forceTranslate = document.getElementById('pdf-translate').checked;

        try {
            if (alwaysAI) {
                updateStatusBar("æ­£åœ¨å°‡ PDF è½‰ç‚ºåœ–ç‰‡ä»¥é€²è¡Œ AI å®Œæ•´è¾¨è­˜...", "busy");
                const images = await convertPdfToImages(file);
                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘å‚³å…¥æ¨¡å¼ï¼Œè®“ performAIProcessing æ±ºå®šæ˜¯å¦éœ€è¦ã€Œå…ˆOCRå†ç¿»è­¯ã€
                await performAIProcessing(images, forceTranslate ? "translate_only" : "ocr_strict", null);
                return;
            }

            updateStatusBar("æ­£åœ¨å˜—è©¦æœ¬æ©Ÿæå–æ–‡å­— (æ”¯æ´å¤šåœ‹èªè¨€)...", "busy");
            const localText = await extractTextFromPDF(file, true); 

            const charCount = localText ? localText.replace(/\s/g, '').length : 0;

            if (charCount > 20) {
                if (forceTranslate) {
                    updateStatusBar("æœ¬æ©Ÿæå–æˆåŠŸï¼Œæ­£åœ¨å‚³é€çµ¦ AI é€²è¡Œå®Œæ•´ç¿»è­¯...", "busy");
                    await performAIProcessing(null, "translate_text", localText);
                } else {
                    updateStatusBar("æœ¬æ©Ÿæå–å®Œæˆ", "ready");
                    addMessage('assistant', localText);
                    playAudioCue('success');
                    const output = document.getElementById('chat-output');
                    output.lastChild.focus();
                }
            } else {
                updateStatusBar(`æœ¬æ©Ÿæå–æ–‡å­—éå°‘ (${charCount} å­—)ï¼Œè½‰ç‚ºåœ–ç‰‡æ¨¡å¼äº¤ç”± AI è­˜åˆ¥...`, "busy");
                const images = await convertPdfToImages(file);
                await performAIProcessing(images, forceTranslate ? "translate_only" : "ocr_strict", null);
            }
        } catch (e) {
            console.error(e); updateStatusBar("PDF è™•ç†éŒ¯èª¤: " + e.message, "error"); playAudioCue('error'); addMessage('error', "PDF è™•ç†å¤±æ•—: " + e.message);
        }
    }

    async function convertPdfToImages(file) {
        const arrayBuffer = await file.arrayBuffer();
        
        const loadingTask = window.pdfjsLib.getDocument({
            data: arrayBuffer,
            cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4.449/cmaps/',
            cMapPacked: true,
        });

        loadingTask.onPassword = function (updatePassword, reason) {
            playAudioCue('error');
            if (reason === window.pdfjsLib.PasswordResponses.NEED_PASSWORD) {
                updateStatusBar("æ–‡ä»¶å—ä¿è­·ï¼Œè«‹è¼¸å…¥å¯†ç¢¼...", "busy");
                const password = prompt("é€™ä»½æ–‡ä»¶å—å¯†ç¢¼ä¿è­·ï¼Œè«‹è¼¸å…¥å¯†ç¢¼ï¼š");
                updatePassword(password);
            } else if (reason === window.pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) {
                updateStatusBar("å¯†ç¢¼éŒ¯èª¤ï¼", "error");
                alert("å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¼¸å…¥ã€‚");
                const password = prompt("å¯†ç¢¼éŒ¯èª¤ï¼è«‹é‡æ–°è¼¸å…¥ï¼š");
                updatePassword(password);
            }
        };
        
        const pdf = await loadingTask.promise;
        const maxPages = pdf.numPages;
        const images = [];
        const limit = Math.min(maxPages, 20); 

        for (let i = 1; i <= limit; i++) {
            updateStatusBar(`æ­£åœ¨æ¸²æŸ“ PDF é é¢ (${i}/${limit})...`, 'busy');
            const page = await pdf.getPage(i);
            
            const viewportRaw = page.getViewport({ scale: 1.0 });
            const MAX_DIMENSION = 2048;
            const maxSide = Math.max(viewportRaw.width, viewportRaw.height);
            let finalScale = 1.5; 
            if (maxSide * finalScale > MAX_DIMENSION) {
                finalScale = MAX_DIMENSION / maxSide;
            }
            
            const viewport = page.getViewport({ scale: finalScale });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport: viewport }).promise;
            
            const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
            images.push(dataUrl.split(',')[1]); 
        }
        return images;
    }

    // ã€æ ¸å¿ƒä¿®æ­£ã€‘performAIProcessing é‡æ§‹ç‚ºå…©éšæ®µï¼šOCR (Accumulate) -> Translate
    async function performAIProcessing(inputData, mode, textData) {
        const controller = new AbortController(); 
        chatHistory = []; 
        const isImageArray = Array.isArray(inputData);
        
        // --- è®Šæ•¸æº–å‚™ ---
        let accumulatedText = "";
        
        // --- éšæ®µä¸€ï¼šæ–‡æœ¬ç²å– (è‹¥ç‚ºåœ–ç‰‡å‰‡ OCRï¼Œè‹¥ç‚ºæ–‡å­—å‰‡ç›´æ¥ä½¿ç”¨) ---
        if (isImageArray) {
            // å¼·åˆ¶ä½¿ç”¨ OCR æ¨¡å¼é€²è¡Œè­˜åˆ¥
            const ocrMode = "ocr_strict";
            const ocrSystemPrompt = memoryPrompts.ocr;
            
            // æ±ºå®š OCR çš„ Provider & Key & Model
            let ocrProvider = document.getElementById('provider-select').value;
            let ocrModel = currentActiveModelId;
            if (specificConfigs.ocr) {
                ocrProvider = specificConfigs.ocr.provider;
                ocrModel = specificConfigs.ocr.model;
            }
            let ocrApiKey = (ocrProvider === document.getElementById('provider-select').value) 
                            ? document.getElementById('api-key').value 
                            : localStorage.getItem(`${ocrProvider}_key`);

            if (!ocrApiKey) throw new Error(`æ‰¾ä¸åˆ° ${ocrProvider} (OCRç”¨) çš„ API Keyã€‚`);

            updateStatusBar(`éšæ®µ 1/2: æ­£åœ¨ OCR ${inputData.length} é æ–‡ä»¶...`, "busy");
            const singlePagePrompt = "Transcribe this page exactly.";

            for (let i = 0; i < inputData.length; i++) {
                const imgBase64 = inputData[i];
                const pageNum = i + 1;
                let success = false;
                let retryCount = 0;

                while (!success && retryCount < 3) {
                    try {
                        updateStatusBar(`[OCR ${ocrProvider}] è™•ç†ä¸­: ç¬¬ ${pageNum}/${inputData.length} é ${retryCount>0?` (é‡è©¦ ${retryCount})`:''} ...`, "busy");
                        let res = await callAI(ocrProvider, singlePagePrompt, imgBase64, "image/jpeg", controller.signal, ocrModel, ocrApiKey, ocrSystemPrompt);
                        res = smartMergeLines(res);
                        const pageContent = `## [ç¬¬ ${pageNum} é ]\n${res}\n\n`;
                        accumulatedText += pageContent;
                        success = true;
                        if (i < inputData.length - 1) await sleep(2000); // é¿å…é€Ÿç‡é™åˆ¶
                    } catch (err) {
                        if (err.message.includes("429")) {
                            updateStatusBar(`æµé‡é™åˆ¶ï¼Œ30ç§’å¾Œé‡è©¦...`, "busy");
                            await sleep(30000);
                            retryCount++;
                        } else {
                            accumulatedText += `## [ç¬¬ ${pageNum} é ]\n(è™•ç†å¤±æ•—: ${err.message})\n\n`;
                            success = true; 
                        }
                    }
                }
            }
        } else {
            // è‹¥åŸæœ¬å°±æ˜¯æ–‡å­—æ¨¡å¼ï¼Œç›´æ¥ä½¿ç”¨
            accumulatedText = textData;
        }

        // --- éšæ®µäºŒï¼šæ ¹æ“šçµæœæ±ºå®š è¼¸å‡º æˆ– ç¿»è­¯ ---
        // åˆ¤æ–·æ˜¯å¦éœ€è¦ç¿»è­¯ (mode åŒ…å« translate)
        if (mode === "translate_only" || mode === "translate_text") {
            const transMode = "translate_text";
            const transSystemPrompt = memoryPrompts.translate;

            // æ±ºå®š Translate çš„ Provider & Key & Model
            let transProvider = document.getElementById('provider-select').value;
            let transModel = currentActiveModelId;
            if (specificConfigs.translate) {
                transProvider = specificConfigs.translate.provider;
                transModel = specificConfigs.translate.model;
            }
            let transApiKey = (transProvider === document.getElementById('provider-select').value)
                              ? document.getElementById('api-key').value
                              : localStorage.getItem(`${transProvider}_key`);

            if (!transApiKey) throw new Error(`æ‰¾ä¸åˆ° ${transProvider} (ç¿»è­¯ç”¨) çš„ API Keyã€‚`);

            updateStatusBar(`éšæ®µ 2/2: [${transProvider}] æ­£åœ¨æ ¹æ“šå…¨æ–‡é€²è¡Œç¿»è­¯...`, "busy");
            const userTransPrompt = `[SOURCE TEXT TO TRANSLATE]:\n${accumulatedText}`;
            
            try {
                const finalRes = await callAI(transProvider, userTransPrompt, null, null, controller.signal, transModel, transApiKey, transSystemPrompt);
                addMessage('assistant', finalRes);
            } catch (e) {
                if (e.message.includes("Failed to fetch") && transProvider === 'gemini') {
                    throw new Error("CORS éŒ¯èª¤: Google æ‹’çµ•é€£ç·šï¼Œè«‹æ”¹ç”¨ OpenRouterã€‚");
                }
                throw e;
            }

        } else {
            // ä¸éœ€è¦ç¿»è­¯ï¼Œç›´æ¥è¼¸å‡º OCR çµæœ
            updateStatusBar("è™•ç†å®Œæˆ", "ready");
            addMessage('assistant', accumulatedText);
        }

        playAudioCue('success'); updateStatusBar("ä»»å‹™å®Œæˆ", "ready");
        document.getElementById('chat-output').lastChild.focus();
        document.getElementById('system-prompt').value = memoryPrompts[currentEditingMode]; // æ¢å¾© UI é¡¯ç¤º
    }

    async function extractTextFromPDF(file, reportProgress = false) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = window.pdfjsLib.getDocument({
                data: arrayBuffer,
                cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4.449/cmaps/',
                cMapPacked: true,
            });

            loadingTask.onPassword = function (updatePassword, reason) {
                playAudioCue('error');
                if (reason === window.pdfjsLib.PasswordResponses.NEED_PASSWORD) {
                    updateStatusBar("éœ€è¦å¯†ç¢¼è§£é– PDF...", "busy");
                    const password = prompt("é€™ä»½æ–‡ä»¶å—å¯†ç¢¼ä¿è­·ï¼Œè«‹è¼¸å…¥å¯†ç¢¼ï¼š");
                    updatePassword(password);
                } else if (reason === window.pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) {
                    updateStatusBar("å¯†ç¢¼éŒ¯èª¤", "error");
                    alert("å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¼¸å…¥ã€‚");
                    const password = prompt("å¯†ç¢¼éŒ¯èª¤ï¼è«‹é‡æ–°è¼¸å…¥ï¼š");
                    updatePassword(password);
                }
            };

            const pdf = await loadingTask.promise;
            let fullText = "";
            const maxPages = pdf.numPages;
            const isCJK = (c) => /[\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\uFF00-\uFFEF]/.test(c);

            for (let i = 1; i <= maxPages; i++) {
                if (reportProgress) updateStatusBar(`æ­£åœ¨æå–æ–‡å­— (ç¬¬ ${i} / ${maxPages} é )...`, "busy");
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                let lines = [];
                let currentLine = [];
                
                for (const item of textContent.items) {
                    if (!item.str) continue;
                    const y = item.transform[5]; 
                    const height = item.transform[3] || item.height || 10; 
                    if (currentLine.length > 0) {
                        const lastItemY = currentLine[0].transform[5];
                        if (Math.abs(y - lastItemY) > (height * 0.5)) {
                            lines.push(currentLine);
                            currentLine = [];
                        }
                    }
                    currentLine.push(item);
                }
                if (currentLine.length > 0) lines.push(currentLine);

                let processedLines = [];
                for (const line of lines) {
                    line.sort((a, b) => a.transform[4] - b.transform[4]);
                    let lineText = "";
                    let lastItemXEnd = null;
                    let lastChar = "";

                    for (const item of line) {
                        const str = item.str;
                        const x = item.transform[4];
                        const w = item.width;
                        const fontSize = item.transform[0] || 10;
                        if (lastItemXEnd !== null) {
                            const gap = x - lastItemXEnd;
                            if (gap > (fontSize * 0.4)) { 
                                const currChar = str.charAt(0);
                                if (!(isCJK(lastChar) && isCJK(currChar))) { lineText += " "; }
                            }
                        }
                        lineText += str;
                        lastItemXEnd = x + w;
                        lastChar = str.slice(-1);
                    }
                    processedLines.push(lineText.trim());
                }

                let pageParagraphs = "";
                for (let j = 0; j < processedLines.length; j++) {
                    const currLine = processedLines[j];
                    if (j < processedLines.length - 1) {
                        const nextLine = processedLines[j + 1];
                        const lastChar = currLine.slice(-1);
                        const nextChar = nextLine.charAt(0);
                        const isSentenceEnd = /[.ã€‚ï¼ï¼Ÿ?!:;ï¼šï¼›]$/.test(currLine);

                        if (isSentenceEnd) { pageParagraphs += currLine + "\n"; } 
                        else {
                            if (lastChar === '-' && /[a-zA-Z]/.test(currLine.slice(-2, -1))) { pageParagraphs += currLine.slice(0, -1); } 
                            else if (isCJK(lastChar) && isCJK(nextChar)) { pageParagraphs += currLine; } 
                            else { pageParagraphs += currLine + " "; }
                        }
                    } else { pageParagraphs += currLine + "\n"; }
                }
                if (pageParagraphs.trim().length > 0) { fullText += `## [ç¬¬ ${i} é ]\n${pageParagraphs}\n\n`; }
            }
            return fullText.trim();
        } catch (e) {
            console.error("PDF extract error", e);
            if (e.name === 'PasswordException') return null;
            throw e;
        }
    }

    function initVoiceSystem() {
        const engine = document.getElementById('voice-engine').value;
        if (engine === 'browser') initBrowserSpeech(); 
        else if (recognition) { recognition.stop(); recognition = null; }
    }

    function initBrowserSpeech() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition(); 
            recognition.lang = 'zh-HK'; 
            recognition.continuous = true; 
            recognition.interimResults = true; 
            
            recognition.onstart = () => { 
                isVoiceRecording = true;
                const btn = document.getElementById('voice-btn');
                btn.classList.add('recording'); 
                btn.innerText = "æ”¾é–‹å‚³é€...";
                updateStatusBar('æ­£åœ¨è†è½...', 'recording'); 
                playAudioCue('start'); 
            };
            
            recognition.onresult = (e) => {
                let t = ''; 
                for (let i = e.resultIndex; i < e.results.length; ++i) {
                    if (e.results[i].isFinal) t += e.results[i][0].transcript;
                }
                if (t) document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + t;
            };
            
            recognition.onerror = (e) => { 
                if (e.error !== 'aborted' && e.error !== 'no-speech') {
                    showTransientStatus('èªéŸ³éŒ¯èª¤: ' + e.error, 'error'); 
                    playAudioCue('error');
                }
                stopVoiceInputUI();
            };
            
            recognition.onend = () => { 
                if (isVoiceRecording) {
                    playAudioCue('abort'); 
                    showTransientStatus('éŒ„éŸ³å·²ä¸­æ–· (ç³»çµ±é™åˆ¶)', 'error');
                }
                stopVoiceInputUI();
            };
        }
    }

    async function startVoiceRecording() {
        if (isVoiceRecording) return;
        const engine = document.getElementById('voice-engine').value;
        
        if (engine === 'browser') {
            if (recognition) {
                try { recognition.start(); } catch(e) { console.error(e); }
            }
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = []; 
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => { 
                    await processWhisperAudio(new Blob(audioChunks, {type: mediaRecorder.mimeType}), engine, mediaRecorder.mimeType); 
                    stream.getTracks().forEach(t=>t.stop()); 
                };
                mediaRecorder.start(); 
                isVoiceRecording = true;
                document.getElementById('voice-btn').classList.add('recording');
                document.getElementById('voice-btn').innerText = "æ”¾é–‹å‚³é€...";
                playAudioCue('start');
            } catch (e) { 
                showTransientStatus('éº¥å…‹é¢¨éŒ¯èª¤', 'error'); playAudioCue('error'); 
            }
        }
    }

    function stopVoiceRecording() {
        if (!isVoiceRecording) return;
        const engine = document.getElementById('voice-engine').value;
        playAudioCue('success');
        isVoiceRecording = false; 

        if (engine === 'browser' && recognition) {
            recognition.stop();
        } else if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            showTransientStatus('æ­£åœ¨è™•ç†éŒ„éŸ³...', 'busy');
        }
    }

    function stopVoiceInputUI() {
        isVoiceRecording = false;
        const btn = document.getElementById('voice-btn');
        btn.classList.remove('recording');
        btn.innerText = "æŒ‰ä½èªªè©±";
        if (!document.getElementById('status-bar').classList.contains('busy')) {
             showReadyStatus();
        }
    }

    async function processWhisperAudio(blob, engine, mime) {
        let apiKey = document.getElementById('voice-api-key').value || document.getElementById('api-key').value;
        if (!apiKey) return alert("éœ€ API Key");
        const fd = new FormData(); fd.append('file', blob, `rec.${mime.includes('mp4')?'mp4':'webm'}`);
        fd.append('model', engine === 'openai' ? 'whisper-1' : 'whisper-large-v3');
        try {
            const res = await fetch(engine==='openai'?"https://api.openai.com/v1/audio/transcriptions":"https://api.groq.com/openai/v1/audio/transcriptions", { method:'POST', headers:{'Authorization':`Bearer ${apiKey}`}, body:fd });
            const data = await res.json();
            if (data.text) { document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + data.text; showTransientStatus("å®Œæˆ"); }
        } catch(e) { showTransientStatus("éŒ¯èª¤", 'error'); playAudioCue('error'); }
        finally { stopVoiceInputUI(); }
    }

    function saveVoiceSettings() { localStorage.setItem('voice_engine', document.getElementById('voice-engine').value); localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value); initVoiceSystem(); }
    function initPasteImage() { document.addEventListener('paste', e => { const f = e.clipboardData.files[0]; if(f && f.type.startsWith('image/')) handleFileSelect(f); }); }
    function initDragAndDrop() { const d = document.getElementById('user-input'); d.ondragover = e => {e.preventDefault(); d.classList.add('dragover')}; d.ondragleave = () => d.classList.remove('dragover'); d.ondrop = e => {e.preventDefault(); d.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files[0]);}; }
    function initEnterKey() { document.getElementById('user-input').onkeydown = e => { if(e.key==='Enter' && !e.shiftKey && document.getElementById('enter-to-send').checked) { e.preventDefault(); document.getElementById('submit-btn').click(); } }; }
    
    function updateStatusBar(t, s='ready') { 
        const b = document.getElementById('status-bar'); 
        b.innerText = t; 
        b.className = s; 
        b.setAttribute('aria-live', s === 'error' ? 'assertive' : 'polite');
    }
    
    function showReadyStatus() { updateStatusBar("æº–å‚™å°±ç·’"); }
    function showTransientStatus(m, t='success') { updateStatusBar(m, t==='error'?'error':'ready'); setTimeout(()=>{ if(!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus(); }, 3000); }
    function addMessage(role, content) {
        const div = document.createElement('div'); div.className = `message ${role}`; div.tabIndex = -1;
        div.innerHTML = `<h1 class="msg-heading">${role==='user'?'è¼¸å…¥å•é¡Œï¼š':(role==='error'?'ç™¼ç”ŸéŒ¯èª¤ï¼š':'å›æ‡‰çµæœï¼š')}</h1><div class="markdown-body">${role==='user'?content:DOMPurify.sanitize(marked.parse(content))}</div>`;
        if(role==='assistant') {
            const btn = document.createElement('button'); btn.className='mini-copy-btn'; btn.innerText='è¤‡è£½ (Alt+Shift+R)';
            btn.onclick = () => navigator.clipboard.writeText(div.querySelector('.markdown-body').innerText).then(()=>showTransientStatus('å·²è¤‡è£½'));
            div.appendChild(btn);
        }
        document.getElementById('chat-output').appendChild(div); return div;
    }
    function toggleExportButtons(show) { ['copy-btn','export-txt-btn','export-html-btn'].forEach(id=>document.getElementById(id).classList.toggle('hidden', !show)); }
    
    function handleProviderChange(save=true) {
        const p = document.getElementById('provider-select').value; const c = PROVIDERS[p];
        document.getElementById('api-key').value = localStorage.getItem(`${p}_key`) || "";
        
        memoryPrompts.chat = localStorage.getItem(`${p}_prompt`) || c.prompt;
        
        if (currentEditingMode === 'chat') {
            document.getElementById('system-prompt').value = memoryPrompts.chat;
        }

        document.getElementById('openrouter-settings').classList.toggle('hidden', p!=='openrouter');
        allCurrentModels = JSON.parse(localStorage.getItem(`${p}_model_list`)) || c.models;
        handleModelFilter();
        currentActiveModelId = localStorage.getItem(`${p}_model`) || c.defaultModel;
        document.getElementById('refresh-btn').style.display = c.canFetch ? 'block' : 'none';
        if(save) localStorage.setItem('provider', p);
        resetConversation(); showReadyStatus();
    }
    function handleModelFilter() {
        const f = document.getElementById('model-filter-input').value.toLowerCase();
        updateModelSelect(allCurrentModels.filter(m=>m.toLowerCase().includes(f)), currentActiveModelId);
    }
    function updateModelSelect(list, active) {
        const s = document.getElementById('model-select'); s.innerHTML = "";
        let found = false;
        list.forEach(m => { const o = document.createElement('option'); o.value=m; o.innerText=m; if(m===active) found=true; s.appendChild(o); });
        const cust = document.createElement('option'); cust.value="CUSTOM"; cust.innerText="è‡ªè¡Œè¼¸å…¥..."; s.appendChild(cust);
        const w = document.getElementById('custom-model-wrapper');
        if(found) { s.value=active; w.classList.add('hidden'); } else { s.value="CUSTOM"; w.classList.remove('hidden'); document.getElementById('custom-model-input').value=active; }
    }
    async function fetchOnlineModels() {
        const p = document.getElementById('provider-select').value; const k = document.getElementById('api-key').value;
        if(!k && p!=='openrouter') return alert("éœ€ API Key");
        const btn = document.getElementById('refresh-btn'); btn.innerText="è®€å–ä¸­..."; btn.disabled=true;
        try {
            let list=[];
            if(p==='openrouter') list=(await(await fetch("https://openrouter.ai/api/v1/models")).json()).data.map(m=>m.id);
            else if(p==='gemini') list=(await(await fetch(PROVIDERS[p].listUrl.replace('{KEY}',k))).json()).models.filter(m=>m.supportedGenerationMethods?.includes("generateContent")).map(m=>m.name.replace("models/",""));
            else list=(await(await fetch(PROVIDERS[p].listUrl, {headers:{'Authorization':`Bearer ${k}`}})).json()).data.map(m=>m.id);
            if(list.length) { localStorage.setItem(`${p}_model_list`, JSON.stringify(list)); allCurrentModels=list; handleModelFilter(); showTransientStatus("å·²æ›´æ–°"); }
        } catch(e) { showTransientStatus("æ›´æ–°å¤±æ•—", 'error'); } finally { btn.innerText="æ›´æ–°"; btn.disabled=false; }
    }
    function handleModelSelectChange() {
        const s = document.getElementById('model-select');
        if(s.value==="CUSTOM") document.getElementById('custom-model-wrapper').classList.remove('hidden');
        else { document.getElementById('custom-model-wrapper').classList.add('hidden'); currentActiveModelId=s.value; }
        resetConversation();
    }
    function handleCustomInputChange() { currentActiveModelId = document.getElementById('custom-model-input').value.trim(); resetConversation(); }
    
    function saveSettings() {
        const p = document.getElementById('provider-select').value;
        const m = document.getElementById('model-select').value==="CUSTOM" ? document.getElementById('custom-model-input').value : document.getElementById('model-select').value;
        
        memoryPrompts[currentEditingMode] = document.getElementById('system-prompt').value;

        localStorage.setItem(`${p}_prompt`, memoryPrompts.chat);
        
        localStorage.setItem('custom_prompt_ocr', memoryPrompts.ocr);
        localStorage.setItem('custom_prompt_translate', memoryPrompts.translate);

        localStorage.setItem(`${p}_key`, document.getElementById('api-key').value.trim());
        localStorage.setItem(`${p}_model`, m); currentActiveModelId = m;
        localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
        localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
        localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
        saveVoiceSettings(); showTransientStatus("å·²å„²å­˜"); document.getElementById('settings-area').open = false;
    }

    function restoreDefaults() {
        const p = document.getElementById('provider-select').value; 
        
        memoryPrompts.chat = PROVIDERS[p].prompt;
        memoryPrompts.ocr = DEFAULT_OCR_PROMPT;
        memoryPrompts.translate = DEFAULT_TRANSLATE_PROMPT;

        localStorage.removeItem(`${p}_prompt`);
        localStorage.removeItem('custom_prompt_ocr');
        localStorage.removeItem('custom_prompt_translate');

        document.getElementById('system-prompt').value = memoryPrompts[currentEditingMode];
        
        localStorage.removeItem(`${p}_model`); 
        handleProviderChange(true); 
        showTransientStatus("å·²é‚„åŸé è¨­å€¼");
    }

    function copyResult() { navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(()=>showTransientStatus("å·²è¤‡è£½")); }
    function exportChat(fmt) {
        const c = document.getElementById('chat-output');
        const b = new Blob([fmt==='html'?`<html><body>${c.innerHTML}</body></html>`:c.innerText], {type:fmt==='html'?'text/html':'text/plain'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `export.${fmt}`; a.click();
    }
    function handleFileSelect(f) {
        if(f) { selectedFile=f; document.getElementById('upload-btn').innerText=`å·²é¸: ${f.name}`; showTransientStatus("å·²åŠ å…¥"); if(!document.getElementById('pause-send').checked) setTimeout(()=>document.querySelector('form').requestSubmit(), 500); }
    }
    function readFileAsBase64(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result.split(',')[1]); rd.onerror=j; rd.readAsDataURL(f);}); }

    async function handleSubmit(e) {
        e.preventDefault(); const txt = document.getElementById('user-input').value.trim();
        if(!txt && !selectedFile) return showTransientStatus("è«‹è¼¸å…¥", 'error');
        playAudioCue('start'); updateStatusBar("è™•ç†ä¸­...", 'busy');
        const btn = document.getElementById('submit-btn'); btn.disabled=true;
        const ctl = new AbortController(); const tm = setTimeout(()=>ctl.abort(), document.getElementById('timeout-setting').value*1000);
        try {
            let input = txt; let fileData = null; let mime = null; let skipFile = false;
            if(selectedFile) {
                if(selectedFile.type==='application/pdf') {
                    const pdfText = await extractTextFromPDF(selectedFile);
                    const charCount = pdfText ? pdfText.replace(/\s/g, '').length : 0;
                    if(charCount > 20) { input=`[PDF]:\n${pdfText}\n\n${txt}`; skipFile=true; }
                    else { 
                        fileData = await convertPdfToImages(selectedFile); 
                        mime = "application/pdf-images"; 
                    }
                } else { 
                    fileData=await readFileAsBase64(selectedFile); mime=selectedFile.type; 
                }
            }
            if (mime === "application/pdf-images") {
                await performAIProcessing(fileData, "ocr_strict", null);
            } else {
                const res = await callAI(document.getElementById('provider-select').value, input, skipFile?null:fileData, mime, ctl.signal, null, null, memoryPrompts.chat);
                document.getElementById('user-input').value=""; document.getElementById('upload-btn').innerText="é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)"; selectedFile=null;
                addMessage('user', txt||"[æª”æ¡ˆ]"); const ai = addMessage('assistant', res); ai.focus(); chatHistory.push({role:'user',content:input}); chatHistory.push({role:'assistant',content:res});
                playAudioCue('success'); showReadyStatus();
            }
        } catch(e) { addMessage('error', e.message); playAudioCue('error'); showReadyStatus(); } finally { clearTimeout(tm); btn.disabled=false; }
    }

    async function callAI(p, txt, file, mime, sig, ovModel, ovKey, ovSystemPrompt) {
        const k = ovKey || document.getElementById('api-key').value; 
        const m = ovModel || currentActiveModelId;
        const sys = ovSystemPrompt || document.getElementById('system-prompt').value; 
        
        if(!k) throw new Error("éœ€ API Key");
        let body={}, url="", headers={'Content-Type':'application/json', 'Authorization':`Bearer ${k}`};
        
        const isMultiImage = Array.isArray(file);
        if (isMultiImage) { mime = "image/jpeg"; }

        if(p==='gemini') {
            url=`https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}`; delete headers['Authorization'];
            let parts = [];
            if (isMultiImage) {
                file.forEach(b64 => parts.push({inline_data:{mime_type:"image/jpeg", data:b64}}));
                parts.push({text:txt});
            } else {
                parts = file ? [{inline_data:{mime_type:mime, data:file}}, {text:txt}] : [{text:txt}];
            }
            body = { system_instruction:{parts:[{text:sys}]}, contents:[{role:"user", parts:parts}] };
        } else {
            if (p === 'openrouter') {
                url = "https://openrouter.ai/api/v1/chat/completions";
                headers['HTTP-Referer'] = location.href;
                if(document.getElementById('openrouter-web-search').checked) body.plugins = [{id:"web"}];
            } else if (p === 'mistral') {
                url = "https://api.mistral.ai/v1/chat/completions";
            } else if (p === 'perplexity') {
                url = "https://api.perplexity.ai/chat/completions";
            } else if (p === 'openai') {
                url = "https://api.openai.com/v1/chat/completions";
            } else {
                url = "https://api.groq.com/openai/v1/chat/completions";
            }

            let content = [];
            if (isMultiImage) {
                content.push({type:"text", text:txt});
                file.forEach(b64 => content.push({type:"image_url", image_url:{url:`data:image/jpeg;base64,${b64}`}}));
            } else {
                content = file ? [{type:"text",text:txt}, {type:"image_url",image_url:{url:`data:${mime};base64,${file}`}}] : txt;
            }
            body = { ...body, model:m, messages:[{role:"system",content:sys}, {role:"user",content:content}], temperature:0.3 };
        }
        
        const r = await fetch(url, {method:'POST', headers, body:JSON.stringify(body), signal:sig});
        if(!r.ok) throw new Error(await r.text()); const d = await r.json();
        return p==='gemini' ? (d.candidates?.[0]?.content?.parts?.[0]?.text||"ç„¡å›æ‡‰") : (d.choices?.[0]?.message?.content||"ç„¡å›æ‡‰");
    }
</script>
</body>
</html>
