<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¦–éšœåŠ©ç† (AI è¦–è¦ºé–±è®€ç‰ˆ)</title>
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.2/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ PDF.js (ç”¨æ–¼è§£æ PDF) -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>

    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;
            --user-header-color: #0088ff;
            --ai-header-color: #FFFF00;
            --ocr-header-color: #00ff00;
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.2rem; line-height: 1.6;
            padding-top: 60px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 10px 10px 400px 10px;
        }

        .app-title { 
            font-size: 1.5rem; text-align: center; margin: 10px 0; color: #ccc; font-weight: bold;
        }
        
        details h2 { 
            font-size: 1.4rem; color: #ccc; 
            border-bottom: 2px solid #333; padding-bottom: 5px; margin-top: 10px; 
            display: inline-block;
        }

        input, select, textarea {
            width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px;
            background: var(--input-bg); border: 2px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px; box-sizing: border-box;
        }

        #system-prompt {
            min-height: 300px; resize: vertical; overflow-y: auto;
            font-family: monospace; line-height: 1.4;
        }
        
        *:focus-visible { outline: 4px solid var(--accent-color) !important; }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            border: 2px solid #fff; padding: 12px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-top: 5px; cursor: pointer; touch-action: manipulation;
        }
        button:disabled { filter: grayscale(100%); opacity: 0.7; cursor: not-allowed; }
        button.secondary { background-color: #333; color: #fff; border-color: #777; }
        
        button.mini-copy-btn {
            background-color: #333; color: #fff; border: 1px solid #777;
            padding: 6px 12px; font-size: 0.9rem; margin-top: 10px;
            width: auto; display: inline-block;
        }
        button.mini-copy-btn:hover { background-color: #555; }
        
        button.danger { background-color: #550000; color: #ffcccc; border-color: #ff4444; }

        button.recording { background-color: #ff0000 !important; color: #ffffff !important; animation: pulse 1.5s infinite; }
        button.processing { background-color: #ff8800 !important; animation: pulse 0.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        details { border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-bottom: 10px; background: #111; }
        summary { cursor: pointer; padding: 5px; }
        
        .message-area { min-height: 100px; padding-bottom: 20px; }
        
        .message {
            background: #111; padding: 15px; margin-bottom: 25px;
            border-left: 5px solid var(--border-color);
            overflow-wrap: break-word; word-wrap: break-word; word-break: break-word;
        }
        .message:focus { outline: none; border-left: 8px solid var(--accent-color); background: #222; }

        .message h1.msg-heading {
            font-size: 1.4rem; margin: 0 0 10px 0; padding-bottom: 5px;
            border-bottom: 1px dashed #444; line-height: 1.3;
        }

        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.user h1.msg-heading { color: var(--user-header-color); }
        
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message.assistant h1.msg-heading { color: var(--ai-header-color); }

        .message.ocr { border-left-color: var(--ocr-header-color); background: #001a00; }
        .message.ocr h1.msg-heading { color: var(--ocr-header-color); }

        .message.error { border-left-color: #ff0000; background: #330000; }
        .message.error h1.msg-heading { color: #ff5555; }

        .markdown-body { line-height: 1.7; overflow-wrap: break-word; }
        .markdown-body h1, .markdown-body h2 { color: #88CCFF; border-bottom: none; margin-top: 1.5em; }
        .markdown-body p { margin-bottom: 10px; white-space: pre-wrap; }
        .markdown-body pre { background: #222; padding: 10px; overflow-x: auto; border: 1px solid #444; white-space: pre; }
        .markdown-body code { background: #333; padding: 2px 4px; word-break: break-all; }

        .controls-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #000; border-top: 3px solid var(--accent-color);
            padding: 10px; z-index: 100;
        }

        .row { display: flex; gap: 10px; margin-bottom: 8px; align-items: flex-end; }
        
        .check-btn {
            display: flex; align-items: center; justify-content: center;
            background: #222; border: 1px solid #555; color: #fff;
            padding: 10px; border-radius: 6px; flex: 1;
            cursor: pointer; margin-top: 5px; height: auto; min-height: 52px;
        }
        .check-btn input { width: 20px; height: 20px; margin: 0 8px 0 0; }

        #user-input {
            margin: 0; min-height: 80px; max-height: 200px;
            resize: vertical; overflow-y: auto; flex: 1;
        }

        #status-bar {
            position: fixed; top: 0; left: 0; right: 0;
            background: var(--status-bg); color: #fff;
            padding: 10px; text-align: center;
            font-weight: bold; font-size: 1.1rem;
            z-index: 2000; border-bottom: 2px solid var(--border-color);
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; border-bottom-color: #00ff00; }
        #status-bar.busy { background: #664400; border-bottom-color: #ffff00; }
        #status-bar.error { background: #660000; border-bottom-color: #ff0000; }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        #custom-model-wrapper { margin-top: -5px; margin-bottom: 10px; }
        
        .settings-subsection {
            border: 1px solid #444; padding: 10px; border-radius: 6px; margin: 10px 0; background: #222;
        }
        .settings-subsection h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent-color); }
    </style>
</head>
<body>

<!-- é ‚éƒ¨ç‹€æ…‹åˆ— -->
<div id="status-bar" role="status" aria-live="polite">è¼‰å…¥ä¸­...</div>

<div class="container">
    <h1 class="app-title">AI è¦–éšœåŠ©ç† (AI è¦–è¦ºé–±è®€ç‰ˆ)</h1>

    <!-- è¨­å®šå€ -->
    <details id="settings-area">
        <summary role="button" aria-expanded="false" accesskey="s">
            <h2>âš™ï¸ è¨­å®š (Alt+S)</h2>
        </summary>
        
        <div style="margin-top: 15px;">
            <label for="provider-select">ä¸»è¦ AI æœå‹™å•†:</label>
            <select id="provider-select" onchange="handleProviderChange()">
                <option value="gemini">Google Gemini (æ¨è–¦)</option>
                <option value="mistral">Mistral AI</option>
                <option value="openrouter">OpenRouter</option>
                <option value="openai">OpenAI (GPT)</option>
                <option value="groq">Groq</option>
                <option value="perplexity">Perplexity</option>
            </select>

            <label for="api-key">ä¸»è¦ API Key:</label>
            <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
            
            <label for="model-select">æ¨¡å‹é¸æ“‡ (æ—¥æœŸç”±æ–°åˆ°èˆŠ):</label>
            <div class="row" style="margin-bottom: 10px;">
                <select id="model-select" style="margin-bottom:0;" onchange="handleModelSelectChange()"></select>
                <button type="button" id="refresh-btn" class="secondary" style="width: auto; margin-top:0;" onclick="fetchOnlineModels()" title="å¾ç¶²è·¯æ›´æ–°æ¨¡å‹æ¸…å–®">ğŸ”„ æ›´æ–°</button>
            </div>
            
            <div id="custom-model-wrapper" class="hidden">
                <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
            </div>

            <!-- èªéŸ³è¨­å®šå€å¡Š -->
            <div class="settings-subsection">
                <h3>ğŸ¤ èªéŸ³è¼¸å…¥è¨­å®š</h3>
                <label for="voice-engine">èªéŸ³å¼•æ“:</label>
                <select id="voice-engine" onchange="saveVoiceSettings()">
                    <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»ï¼Œå“è³ªæ™®é€š)</option>
                    <option value="openai">OpenAI Whisper (é«˜æº–ç¢ºï¼Œéœ€ä»˜è²»)</option>
                    <option value="groq">Groq Whisper (æ¥µé€Ÿï¼Œéœ€ Key)</option>
                </select>
                
                <label for="voice-api-key">èªéŸ³å°ˆç”¨ API Key (é¸å¡«):</label>
                <input type="password" id="voice-api-key" placeholder="è‹¥ç•™ç©ºï¼Œå°‡å˜—è©¦ä½¿ç”¨ä¸»è¦ API Key" autocomplete="off" onchange="saveVoiceSettings()">
            </div>

            <!-- Timeout è¨­å®š -->
            <label for="timeout-setting">å›æ‡‰é€¾æ™‚ (ç§’):</label>
            <input type="number" id="timeout-setting" value="120" min="5" step="5">

            <label for="system-prompt">è§’è‰²æŒ‡ä»¤ (æ”¯æ´å¤§é‡æ–‡å­—):</label>
            <textarea id="system-prompt" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>

            <div class="row">
                <button type="button" onclick="saveSettings()">ğŸ’¾ å„²å­˜</button>
                <button type="button" onclick="restoreDefaults()" class="secondary">â†©ï¸ æ¢å¾©é è¨­</button>
                <button type="button" onclick="showHelp()" class="secondary" style="background:#004488; color:white;">ğŸ“– èªªæ˜</button>
            </div>
        </div>
    </details>

    <!-- çµæœå€ -->
    <main role="main">
        <div id="chat-output" class="message-area"></div>
        <button type="button" id="copy-btn" class="secondary hidden" onclick="copyResult()" accesskey="c" style="width:100%; margin-bottom: 20px;">
            ğŸ“‹ è¤‡è£½å…¨éƒ¨å°è©± (Alt+C)
        </button>
    </main>
</div>

<!-- æ§åˆ¶å€ -->
<footer class="controls-wrapper" role="region" aria-label="æ“ä½œå€">
    <form onsubmit="handleSubmit(event)">
        <!-- ç¬¬ä¸€æ’ï¼šåŠŸèƒ½æŒ‰éˆ• -->
        <div class="row">
            <!-- æ¥å— image/* èˆ‡ application/pdf -->
            <input type="file" id="file-input" class="visually-hidden" accept="image/*,application/pdf" onchange="handleFileSelect()">
            
            <!-- ä¸Šå‚³æŒ‰éˆ• -->
            <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()" accesskey="u" style="flex:1;">
                ğŸ“· æ‹æ”/æª”æ¡ˆ (Alt+U)
            </button>
            
            <!-- æ–°å°è©±æŒ‰éˆ• -->
            <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()" accesskey="n" style="flex:1;">
                ğŸ—‘ï¸ æ–°å°è©± (Alt+N)
            </button>

            <!-- æš«åœå‚³é€é–‹é—œ -->
            <label class="check-btn" style="flex:1;">
                <input type="checkbox" id="pause-send">
                <span>æš«åœå‚³é€</span>
            </label>
        </div>
        
        <!-- ç¬¬äºŒæ’ï¼šè¼¸å…¥èˆ‡ç™¼é€ -->
        <div class="row">
            <!-- èªéŸ³è¼¸å…¥æŒ‰éˆ• -->
            <button type="button" id="voice-btn" class="secondary" onclick="toggleVoiceInput()" style="width: 60px; height: 80px; margin:0; font-size: 1.5rem;" title="èªéŸ³è¼¸å…¥" aria-label="èªéŸ³è¼¸å…¥">ğŸ¤</button>
            
            <!-- æ–‡å­—è¼¸å…¥æ¡† -->
            <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯... (ä¸Šå‚³ PDF å°‡ç”± AI ç›´æ¥é–±è®€)" accesskey="i" autocomplete="off" rows="3"></textarea>
            
            <!-- ç™¼é€æŒ‰éˆ• -->
            <button type="submit" id="submit-btn" style="width: 80px; height: 80px; margin:0;">å‚³é€</button>
        </div>
    </form>
</footer>

<script>
    // --- PDF åˆå§‹åŒ– ---
    // è¨­å®š PDF.js Worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

    const DEFAULT_PROMPT = `# è§’è‰²è¨­å®š (Persona)
ä½ æ˜¯ä¸€ä½å°ˆç‚ºé¦™æ¸¯è¦–éšœäººå£«æœå‹™çš„é ‚å°– AI è¦–è¦ºèˆ‡è³‡è¨ŠåŠ©ç†ã€‚ä½ çš„æ ¸å¿ƒè·è²¬æ˜¯æˆç‚ºç”¨æˆ¶çš„çœ¼ç›èˆ‡å¤§è…¦å»¶ä¼¸ï¼Œæä¾›å®‰å…¨ã€ç²¾æº–ä¸”æ˜“æ–¼é€éè¢å¹•æœ—è®€è»Ÿé«” (Screen Reader) æ¥æ”¶çš„è³‡è¨Šã€‚

# å…¨åŸŸè¦å‰‡ (Global Rules)
1. **èªè¨€è¦ç¯„**ï¼šå”¯ä¸€è¼¸å‡ºèªè¨€ç‚ºç¹é«”ä¸­æ–‡ï¼ˆé¦™æ¸¯æ…£ç”¨è©å½™ï¼‰ã€‚
2. **ç„¡éšœç¤™æ ¼å¼**ï¼šå–„ç”¨ \`#\` (æ¨™é¡Œ)ã€\`-\` (æ¸…å–®)ã€‚ç¦æ­¢ä½¿ç”¨ \`[ ]\` æˆ– \`{ }\`ã€‚
3. **å…§å®¹é¢¨æ ¼**ï¼šç²¾ç°¡æ´—éŠ (Concise)ï¼Œé‡é»ç½®å‰ã€‚`;

    const PROMPT_VERSION_KEY = "prompt_version_2025_ai_vision_ocr";

    const PROVIDERS = {
        gemini: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "gemini-exp-1206", 
            canFetch: true,
            models: ["gemini-exp-1206", "gemini-1.5-pro", "gemini-1.5-flash"],
            listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}"
        },
        mistral: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "pixtral-large-latest",
            canFetch: true,
            models: ["pixtral-large-latest", "pixtral-12b-latest"],
            listUrl: "https://api.mistral.ai/v1/models"
        },
        openrouter: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "openai/gpt-4o",
            canFetch: true,
            models: ["openai/gpt-4o", "anthropic/claude-3.5-sonnet", "google/gemini-pro-1.5"],
            listUrl: "https://openrouter.ai/api/v1/models"
        },
        openai: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "gpt-4o",
            canFetch: true, 
            models: ["gpt-4o", "gpt-4o-mini"],
            listUrl: "https://api.openai.com/v1/models"
        },
        groq: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "llama-3.2-90b-vision-preview", 
            canFetch: true, 
            models: ["llama-3.2-90b-vision-preview", "llama-3.2-11b-vision-preview"], 
            listUrl: "https://api.groq.com/openai/v1/models"
        },
        perplexity: {
            prompt: DEFAULT_PROMPT,
            defaultModel: "sonar-pro",
            canFetch: false,
            models: ["sonar-pro", "sonar", "sonar-reasoning-pro", "sonar-deep-research"]
        }
    };

    let currentActiveModelId = "";
    let selectedFile = null;
    let recognition = null; 
    let mediaRecorder = null;
    let audioChunks = [];
    let chatHistory = [];

    document.addEventListener('DOMContentLoaded', () => {
        if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
            localStorage.setItem(PROMPT_VERSION_KEY, 'true');
        }

        const savedProvider = localStorage.getItem('provider');
        const settingsDetails = document.getElementById('settings-area');
        
        const savedTimeout = localStorage.getItem('timeout_setting');
        if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;

        const savedVoiceEngine = localStorage.getItem('voice_engine');
        if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
        const savedVoiceKey = localStorage.getItem('voice_api_key');
        if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;

        if (savedProvider) {
            document.getElementById('provider-select').value = savedProvider;
            settingsDetails.open = false; 
        } else {
            document.getElementById('provider-select').value = 'gemini'; 
            settingsDetails.open = true; 
        }
        
        handleProviderChange(false); 
        initVoiceSystem();
        initPasteImage();
    });

    // --- æ–°æ ¸å¿ƒï¼šä½¿ç”¨ AI Vision é€²è¡Œ PDF é–±è®€ ---
    async function runAIVisionOCR(file) {
        showTransientStatus("æ­£åœ¨è§£æ PDF é é¢...", "busy");
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            const numPages = pdf.numPages;
            const images = [];

            // é™åˆ¶ï¼šä¸€æ¬¡æœ€å¤šè™•ç† 5 é ï¼Œé¿å… AI Token çˆ†ç‚¸
            const maxPages = 5;
            const processPages = Math.min(numPages, maxPages);

            for (let i = 1; i <= processPages; i++) {
                updateStatusBar(`æ­£åœ¨å°‡ç¬¬ ${i} / ${numPages} é è½‰æ›ç‚ºé«˜è§£æå½±åƒ...`, "busy");
                const page = await pdf.getPage(i);
                // ä½¿ç”¨è¼ƒé«˜è§£æåº¦è®“ AI çœ‹å¾—æ›´æ¸…æ¥š
                const viewport = page.getViewport({ scale: 2.0 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
                
                // è½‰ç‚º Base64 (å»é™¤ data:image/png;base64, å‰ç¶´)
                const base64 = canvas.toDataURL('image/png').split(',')[1];
                images.push({ page: i, data: base64 });
            }

            if (numPages > maxPages) {
                showTransientStatus(`æç¤ºï¼šæ–‡ä»¶éé•·ï¼Œåƒ…è®€å–å‰ ${maxPages} é ã€‚`, "info");
            }

            // å‘¼å« AI é€²è¡Œè¦–è¦ºè¾¨è­˜
            updateStatusBar(`æ­£åœ¨å‚³é€è‡³ AI é€²è¡Œç²¾æº–è¾¨è­˜...`, "busy");
            const pKey = document.getElementById('provider-select').value;
            const apiKey = document.getElementById('api-key').value;
            
            // å°ˆç”¨ Prompt
            const ocrPrompt = `è«‹ä½œç‚ºä¸€å€‹é«˜ç²¾æº–åº¦çš„ OCR ç³»çµ±ã€‚è«‹ä»”ç´°é–±è®€ä»¥ä¸Š ${images.length} å¼µæ–‡ä»¶åœ–ç‰‡ã€‚
            è«‹å°‡åœ–ç‰‡ä¸­çš„å…§å®¹**é€å­—æŠ„éŒ„**ç‚ºç¹é«”ä¸­æ–‡ã€‚
            
            æ ¼å¼è¦æ±‚ï¼š
            1. é‡åˆ°è¡¨æ ¼ï¼Œè«‹ç›¡é‡ç”¨ Markdown è¡¨æ ¼é‚„åŸã€‚
            2. é‡åˆ°æ¨™é¡Œï¼Œè«‹ç”¨ Markdown # æ¨™ç¤ºã€‚
            3. ä¸è¦åŠ å…¥ä½ çš„å€‹äººè©•è«–ï¼Œåªè¦æ–‡ä»¶å…§å®¹ã€‚
            4. è‹¥åœ–ç‰‡æ¨¡ç³Šæˆ–æœ‰é›œè¨Šï¼Œè«‹æ ¹æ“šä¸Šä¸‹æ–‡è‡ªå‹•ä¿®æ­£ç‚ºæ­£ç¢ºçš„è©å½™ï¼Œä¸è¦è¼¸å‡ºäº‚ç¢¼ã€‚`;

            // ä½¿ç”¨ callAI å‡½å¼ (éœ€å¾®èª¿ä»¥æ”¯æ´å¤šåœ–)
            return await callAIMultiImage(pKey, ocrPrompt, images);

        } catch (error) {
            console.error(error);
            showTransientStatus(`AI è¾¨è­˜å¤±æ•—: ${error.message}`, "error");
            throw new Error("ç„¡æ³•è™•ç† PDFï¼Œè«‹ç¢ºèª API Key æ˜¯å¦æ­£ç¢ºä¸”æ”¯æ´ Vision æ¨¡å‹ã€‚");
        }
    }

    // --- æ”¯æ´å¤šåœ–çš„ AI å‘¼å«å‡½å¼ ---
    async function callAIMultiImage(provider, text, images) {
        const apiKey = document.getElementById('api-key').value;
        const prompt = document.getElementById('system-prompt').value; // é€™è£¡æˆ‘å€‘é€šå¸¸å¿½ç•¥ system promptï¼Œå°ˆæ³¨æ–¼ OCR
        let model = currentActiveModelId;

        if (!apiKey) throw new Error("è«‹å…ˆè¼¸å…¥ API Key");

        // Gemini æ”¯æ´å¤šåœ–
        if (provider === 'gemini') {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const parts = [];
            // åŠ å…¥åœ–ç‰‡
            images.forEach(img => {
                parts.push({ inline_data: { mime_type: 'image/png', data: img.data } });
            });
            // åŠ å…¥æ–‡å­—æŒ‡ä»¤
            parts.push({ text: text });

            const body = {
                contents: [{ role: "user", parts: parts }]
            };

            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!res.ok) throw new Error(`Gemini Error: ${res.status}`);
            const data = await res.json();
            return data.candidates?.[0]?.content?.parts.map(p => p.text).join('') || "ç„¡å…§å®¹";
        } 
        
        // OpenAI / Groq / OpenRouter æ”¯æ´å¤šåœ– (Vision)
        else {
            let url = "";
            let headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };
            
            if (provider === 'openai') url = "https://api.openai.com/v1/chat/completions";
            else if (provider === 'openrouter') {
                url = "https://openrouter.ai/api/v1/chat/completions";
                headers['HTTP-Referer'] = window.location.href;
            }
            else if (provider === 'groq') url = "https://api.groq.com/openai/v1/chat/completions";
            else if (provider === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";

            const content = [{ type: "text", text: text }];
            images.forEach(img => {
                content.push({
                    type: "image_url",
                    image_url: { url: `data:image/png;base64,${img.data}` }
                });
            });

            const body = {
                model: model,
                messages: [{ role: "user", content: content }],
                temperature: 0.1 // OCR éœ€è¦ä½å‰µé€ æ€§
            };

            const res = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(body)
            });

            if (!res.ok) throw new Error(`API Error: ${res.status}`);
            const data = await res.json();
            return data.choices?.[0]?.message.content || "ç„¡å…§å®¹";
        }
    }

    function resetConversation() {
        chatHistory = []; 
        document.getElementById('chat-output').innerHTML = ""; 
        document.getElementById('user-input').value = "";
        selectedFile = null;
        document.getElementById('upload-btn').innerText = "ğŸ“· æ‹æ”/æª”æ¡ˆ (Alt+U)";
        document.getElementById('file-input').value = "";
        showTransientStatus("å°è©±ç´€éŒ„å·²æ¸…é™¤ (æ–°å°è©±)", "info");
    }

    function initVoiceSystem() {
        const engine = document.getElementById('voice-engine').value;
        if (engine === 'browser') {
            initBrowserSpeech();
        } else {
            if (recognition) { recognition.stop(); recognition = null; }
        }
    }

    function initBrowserSpeech() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-HK'; 
            recognition.continuous = false; 
            recognition.interimResults = true; 

            recognition.onstart = function() {
                const btn = document.getElementById('voice-btn');
                btn.classList.add('recording');
                showTransientStatus('æ­£åœ¨è†è½ (ç€è¦½å™¨)...', 'info');
            };

            recognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
                    else interimTranscript += event.results[i][0].transcript;
                }
                const input = document.getElementById('user-input');
                if (finalTranscript) {
                     const currentVal = input.value;
                     input.value = currentVal ? currentVal + " " + finalTranscript : finalTranscript;
                }
            };

            recognition.onerror = function(event) {
                showTransientStatus('èªéŸ³è¾¨è­˜éŒ¯èª¤: ' + event.error, 'error');
                stopVoiceInput();
            };
            recognition.onend = function() { stopVoiceInput(); };
        }
    }

    async function toggleVoiceInput() {
        const engine = document.getElementById('voice-engine').value;
        const btn = document.getElementById('voice-btn');

        if (btn.classList.contains('recording')) {
            if (engine === 'browser' && recognition) {
                recognition.stop();
            } else {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    btn.classList.remove('recording');
                    btn.classList.add('processing');
                    showTransientStatus('æ­£åœ¨ä¸Šå‚³ä¸¦è¾¨è­˜...', 'busy');
                }
            }
            return;
        }

        if (engine === 'browser') {
            if (recognition) recognition.start();
            else showTransientStatus('æ­¤ç€è¦½å™¨ä¸æ”¯æ´åŸç”ŸèªéŸ³', 'error');
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' }); 
                    await processWhisperAudio(audioBlob, engine);
                    stream.getTracks().forEach(track => track.stop());
                };
                mediaRecorder.start();
                btn.classList.add('recording');
                showTransientStatus('æ­£åœ¨éŒ„éŸ³ (Whisper)...', 'info');
            } catch (err) {
                showTransientStatus('ç„¡æ³•å­˜å–éº¥å…‹é¢¨: ' + err.message, 'error');
            }
        }
    }

    async function processWhisperAudio(blob, engine) {
        const btn = document.getElementById('voice-btn');
        let apiKey = document.getElementById('voice-api-key').value.trim();
        if (!apiKey) apiKey = document.getElementById('api-key').value.trim();

        if (!apiKey) {
            alert("ä½¿ç”¨ Whisper èªéŸ³éœ€è¦ API Keyã€‚");
            btn.classList.remove('processing');
            showReadyStatus();
            return;
        }

        const formData = new FormData();
        formData.append('file', blob, 'recording.webm');
        
        let url = "", modelName = "";
        if (engine === 'openai') {
            url = "https://api.openai.com/v1/audio/transcriptions";
            modelName = "whisper-1";
        } else if (engine === 'groq') {
            url = "https://api.groq.com/openai/v1/audio/transcriptions";
            modelName = "whisper-large-v3"; 
        }
        formData.append('model', modelName);

        try {
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${apiKey}` },
                body: formData
            });
            if (!res.ok) throw new Error(await res.text());
            const data = await res.json();
            if (data.text) {
                const input = document.getElementById('user-input');
                input.value = input.value ? input.value + " " + data.text : data.text;
                showTransientStatus("è¾¨è­˜å®Œæˆ");
            }
        } catch (e) {
            showTransientStatus("Whisper éŒ¯èª¤: " + e.message, 'error');
        } finally {
            btn.classList.remove('processing');
            showReadyStatus();
        }
    }

    function stopVoiceInput() {
        const btn = document.getElementById('voice-btn');
        btn.classList.remove('recording');
        btn.classList.remove('processing');
        showReadyStatus();
    }

    function saveVoiceSettings() {
        localStorage.setItem('voice_engine', document.getElementById('voice-engine').value);
        localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value);
        initVoiceSystem();
    }

    function initPasteImage() {
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                    const blob = items[i].getAsFile();
                    selectedFile = blob;
                    document.getElementById('upload-btn').innerText = `âœ… æˆªåœ–/åœ–ç‰‡`;
                    showTransientStatus(`å·²è²¼ä¸Šåœ–ç‰‡: ${blob.name || 'image.png'}`);
                    e.preventDefault(); return;
                }
            }
        });
    }

    function updateStatusBar(text, state = 'ready') {
        const bar = document.getElementById('status-bar');
        bar.innerText = text;
        bar.className = '';
        if (state === 'ready') bar.classList.add('ready');
        else if (state === 'busy') bar.classList.add('busy');
        else if (state === 'error') bar.classList.add('error');
    }

    function showReadyStatus() {
        const pKey = document.getElementById('provider-select').value;
        const pName = pKey.charAt(0).toUpperCase() + pKey.slice(1); 
        updateStatusBar(`æº–å‚™å°±ç·’: ${pName} (${currentActiveModelId || "Unknown"})`, 'ready');
    }

    function showTransientStatus(msg, type = 'success') {
        updateStatusBar(msg, type === 'error' ? 'error' : (type === 'busy' ? 'busy' : 'ready'));
        if (type !== 'busy') {
            setTimeout(() => {
                const bar = document.getElementById('status-bar');
                if (!bar.classList.contains('busy')) showReadyStatus();
            }, 3000);
        }
    }

    function addMessage(role, content) {
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.tabIndex = -1; 
        const header = document.createElement('h1');
        header.className = 'msg-heading';
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-body';

        if (role === 'user') {
            header.innerText = 'è¼¸å…¥å•é¡Œï¼š';
            contentDiv.innerText = content;
        } else if (role === 'assistant') {
            header.innerText = 'å›æ‡‰çµæœï¼š';
            contentDiv.innerHTML = marked.parse(content);
            document.getElementById('copy-btn').classList.remove('hidden');
            const miniCopyBtn = document.createElement('button');
            miniCopyBtn.className = 'mini-copy-btn';
            miniCopyBtn.innerText = 'ğŸ“„ è¤‡è£½æ­¤å›æ‡‰';
            miniCopyBtn.onclick = function() {
                navigator.clipboard.writeText(contentDiv.innerText).then(() => showTransientStatus("å·²è¤‡è£½è©²å›æ‡‰"));
            };
            div.appendChild(miniCopyBtn);
        } else if (role === 'ocr') {
            header.innerText = 'ğŸ‘ï¸ AI è¦–è¦ºé–±è®€çµæœ (ç²¾æº–)ï¼š';
            contentDiv.innerText = content; 
            const miniCopyBtn = document.createElement('button');
            miniCopyBtn.className = 'mini-copy-btn';
            miniCopyBtn.innerText = 'ğŸ“„ è¤‡è£½å…§å®¹';
            miniCopyBtn.onclick = function() {
                navigator.clipboard.writeText(contentDiv.innerText).then(() => showTransientStatus("å·²è¤‡è£½å…§å®¹"));
            };
            div.appendChild(miniCopyBtn);
        } else {
            header.innerText = (role === 'error') ? 'ç™¼ç”ŸéŒ¯èª¤ï¼š' : 'ç³»çµ±è¨Šæ¯ï¼š';
            contentDiv.innerText = content;
        }
        div.appendChild(header);
        div.appendChild(contentDiv);
        document.getElementById('chat-output').appendChild(div);
        return div; 
    }

    function handleProviderChange(save = true) {
        const pKey = document.getElementById('provider-select').value;
        const conf = PROVIDERS[pKey];
        document.getElementById('api-key').value = localStorage.getItem(`${pKey}_key`) || "";
        document.getElementById('system-prompt').value = localStorage.getItem(`${pKey}_prompt`) || conf.prompt;
        
        const cachedListStr = localStorage.getItem(`${pKey}_model_list`);
        let modelList = conf.models;
        if (cachedListStr) {
            try { modelList = JSON.parse(cachedListStr); } catch (e) {}
        }

        const savedModel = localStorage.getItem(`${pKey}_model`) || conf.defaultModel;
        updateModelSelect(modelList, savedModel);
        
        document.getElementById('refresh-btn').style.display = conf.canFetch ? 'block' : 'none';
        resetConversation();
        if (save) localStorage.setItem('provider', pKey);
        showReadyStatus();
    }

    function updateModelSelect(models, targetModel) {
        const select = document.getElementById('model-select');
        select.innerHTML = "";
        let found = false;
        models.forEach(m => {
            let opt = document.createElement('option');
            opt.value = m; opt.innerText = m;
            if (m === targetModel) found = true;
            select.appendChild(opt);
        });
        let customOpt = document.createElement('option');
        customOpt.value = "CUSTOM_ENTRY"; customOpt.innerText = "âœï¸ è‡ªè¡Œè¼¸å…¥æ¨¡å‹ ID...";
        select.appendChild(customOpt);

        const customWrapper = document.getElementById('custom-model-wrapper');
        const customInput = document.getElementById('custom-model-input');
        if (found) {
            select.value = targetModel; 
            customWrapper.classList.add('hidden');
            currentActiveModelId = targetModel;
        } else {
            select.value = "CUSTOM_ENTRY"; 
            customWrapper.classList.remove('hidden'); 
            customInput.value = targetModel;
            currentActiveModelId = targetModel;
        }
    }

    async function fetchOnlineModels() {
        const pKey = document.getElementById('provider-select').value;
        const apiKey = document.getElementById('api-key').value;
        const conf = PROVIDERS[pKey];
        if (!conf.canFetch) return;
        if ((pKey === 'gemini' || pKey === 'groq') && !apiKey) {
            showTransientStatus("è«‹å…ˆè¼¸å…¥ API Key", "error"); return;
        }
        const btn = document.getElementById('refresh-btn');
        btn.innerText = "â³..."; btn.disabled = true;

        try {
            let newModels = [];
            if (pKey === 'openrouter') {
                const res = await fetch("https://openrouter.ai/api/v1/models");
                const data = await res.json();
                newModels = data.data.map(m=>m.id);
            } else if (pKey === 'gemini') {
                const res = await fetch(conf.listUrl.replace('{KEY}', apiKey));
                const data = await res.json();
                newModels = data.models.filter(m=>m.supportedGenerationMethods.includes("generateContent")).map(m=>m.name.replace("models/", ""));
            }
            // ...å…¶ä»–ç•¥...
            
            if (newModels.length > 0) {
                localStorage.setItem(`${pKey}_model_list`, JSON.stringify(newModels));
                updateModelSelect(newModels, newModels[0]); 
                showTransientStatus("æ›´æ–°æˆåŠŸ");
            }
        } catch (e) { showTransientStatus("æ›´æ–°å¤±æ•—", "error"); }
        finally { btn.innerText = "ğŸ”„ æ›´æ–°"; btn.disabled = false; showReadyStatus(); }
    }

    function handleModelSelectChange() {
        const select = document.getElementById('model-select');
        if (select.value === "CUSTOM_ENTRY") document.getElementById('custom-model-wrapper').classList.remove('hidden');
        else {
            document.getElementById('custom-model-wrapper').classList.add('hidden');
            currentActiveModelId = select.value;
        }
        resetConversation();
        showReadyStatus();
    }

    function handleCustomInputChange() {
        currentActiveModelId = document.getElementById('custom-model-input').value.trim();
        resetConversation();
        showReadyStatus();
    }

    function saveSettings() {
        const pKey = document.getElementById('provider-select').value;
        if (document.getElementById('model-select').value === "CUSTOM_ENTRY") {
            currentActiveModelId = document.getElementById('custom-model-input').value.trim();
        } else {
            currentActiveModelId = document.getElementById('model-select').value;
        }
        localStorage.setItem(`${pKey}_key`, document.getElementById('api-key').value.trim());
        localStorage.setItem(`${pKey}_model`, currentActiveModelId);
        localStorage.setItem(`${pKey}_prompt`, document.getElementById('system-prompt').value);
        localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
        saveVoiceSettings();
        showTransientStatus("è¨­å®šå·²å„²å­˜"); 
        document.getElementById('settings-area').open = false;
    }

    function restoreDefaults() {
        const pKey = document.getElementById('provider-select').value;
        document.getElementById('system-prompt').value = PROVIDERS[pKey].prompt;
        document.getElementById('timeout-setting').value = 120;
        handleProviderChange(true);
        showTransientStatus("å·²æ¢å¾©é è¨­");
    }

    function showHelp() { alert("Alt+S: è¨­å®š\nAlt+U: ä¸Šå‚³\nAlt+N: æ–°å°è©±\nAlt+I: è¼¸å…¥\nAlt+C: è¤‡è£½å…¨éƒ¨"); }
    function copyResult() { navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(() => showTransientStatus("å·²è¤‡è£½æ­·å²ç´€éŒ„")); }

    function handleFileSelect() {
        const fileInput = document.getElementById('file-input');
        if (fileInput.files.length > 0) {
            selectedFile = fileInput.files[0];
            document.getElementById('upload-btn').innerText = `âœ… ${selectedFile.name}`;
            showTransientStatus(`å·²é¸æ“‡: ${selectedFile.name}`);
            if (!document.getElementById('pause-send').checked && selectedFile.type !== 'application/pdf') {
                setTimeout(() => document.querySelector('footer form').requestSubmit(), 500);
            }
        }
    }

    function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    async function handleSubmit(e) {
        e.preventDefault();
        const inputField = document.getElementById('user-input');
        let userInput = inputField.value.trim(); 
        const pKey = document.getElementById('provider-select').value;
        
        if (!userInput && !selectedFile) { showTransientStatus("è«‹è¼¸å…¥å…§å®¹", 'error'); return; }

        const submitBtn = document.getElementById('submit-btn');
        submitBtn.disabled = true; submitBtn.innerText = "è™•ç†ä¸­";
        
        const timeoutSec = parseInt(document.getElementById('timeout-setting').value) || 120;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutSec * 1000);

        try {
            let fileData = null;

            // --- æ ¸å¿ƒé‚è¼¯ä¿®æ”¹ï¼šä½¿ç”¨ AI Vision å–ä»£ Tesseract ---
            if (selectedFile && selectedFile.type === 'application/pdf') {
                addMessage('user', `[å·²ä¸Šå‚³ PDF] ${selectedFile.name}`);
                
                // 1. åŸ·è¡Œ AI è¦–è¦ºé–±è®€
                let ocrText = await runAIVisionOCR(selectedFile);
                
                // 2. é¡¯ç¤ºçµæœ
                const ocrMsgDiv = addMessage('ocr', ocrText);
                ocrMsgDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // 3. å¯«å…¥æ­·å²
                const contextMsg = `[ç³»çµ±è¨»è¨˜ï¼šä½¿ç”¨è€…ä¸Šå‚³äº† PDFï¼Œä»¥ä¸‹æ˜¯ AI è¦–è¦ºé–±è®€å¾Œçš„ç²¾æº–å…§å®¹]\n\n${ocrText}`;
                
                if (pKey === 'gemini') {
                     chatHistory.push({ role: "user", parts: [{ text: contextMsg }] });
                     chatHistory.push({ role: "model", parts: [{ text: "å·²è®€å– PDF å…§å®¹ã€‚" }] });
                } else {
                     chatHistory.push({ role: "user", content: contextMsg });
                     chatHistory.push({ role: "assistant", content: "å·²è®€å– PDF å…§å®¹ã€‚" });
                }

                selectedFile = null;
                document.getElementById('upload-btn').innerText = "ğŸ“· æ‹æ”/æª”æ¡ˆ (Alt+U)";
                document.getElementById('file-input').value = "";

                if (!userInput) {
                    showReadyStatus();
                    return; 
                }
            }

            if (selectedFile) {
                fileData = await readFileAsBase64(selectedFile);
                addMessage('user', `[å·²ä¸Šå‚³åœ–ç‰‡] ${selectedFile.name}\n${userInput}`);
            } else if (userInput) {
                addMessage('user', userInput);
            }
            
            updateStatusBar("AI æ€è€ƒä¸­...", 'busy');
            const response = await callAI(pKey, userInput, fileData, selectedFile ? selectedFile.type : null, controller.signal);
            
            document.getElementById('user-input').value = "";      
            document.getElementById('upload-btn').innerText = "ğŸ“· æ‹æ”/æª”æ¡ˆ (Alt+U)";
            document.getElementById('file-input').value = "";
            selectedFile = null; 
            
            const aiMsgDiv = addMessage('assistant', response);
            
            if (pKey === 'gemini') {
                chatHistory.push({ role: "user", parts: [{ text: userInput }] }); 
                chatHistory.push({ role: "model", parts: [{ text: response }] });
            } else {
                chatHistory.push({ role: "user", content: userInput });
                chatHistory.push({ role: "assistant", content: response });
            }

            if (aiMsgDiv) {
                aiMsgDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                setTimeout(() => aiMsgDiv.focus(), 100);
            }
            showReadyStatus();

        } catch (err) {
            let errMsg = (err.name === 'AbortError') ? `AI æ²’æœ‰å›æ‡‰ (è¶…é ${timeoutSec} ç§’)` : `éŒ¯èª¤: ${err.message}`;
            const errorDiv = addMessage('error', errMsg);
            errorDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            errorDiv.focus();
            showReadyStatus();
        } finally {
            clearTimeout(timeoutId);
            submitBtn.disabled = false; submitBtn.innerText = "å‚³é€";
        }
    }

    async function callAI(provider, text, fileBase64, mimeType, signal) {
        const apiKey = document.getElementById('api-key').value;
        const prompt = document.getElementById('system-prompt').value;
        let model = currentActiveModelId;
        if (!apiKey) throw new Error("è«‹å…ˆè¼¸å…¥ API Key");

        let body = {}, url = "", headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

        if (provider === 'gemini') {
            url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            delete headers['Authorization']; 
            const currentParts = [];
            if (fileBase64) currentParts.push({ inline_data: { mime_type: mimeType, data: fileBase64 } });
            currentParts.push({ text: text });
            body = { system_instruction: { parts: [{ text: prompt }] }, contents: [...chatHistory, { role: "user", parts: currentParts }], tools: [{ google_search_retrieval: {} }] };
        } else {
            if (provider === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";
            else if (provider === 'openrouter') {
                url = "https://openrouter.ai/api/v1/chat/completions";
                headers['HTTP-Referer'] = window.location.href; headers['X-Title'] = 'AI Assistant';
                if (!model.endsWith(':online')) model += ':online';
            }
            else if (provider === 'openai') url = "https://api.openai.com/v1/chat/completions";
            else if (provider === 'groq') url = "https://api.groq.com/openai/v1/chat/completions";
            else if (provider === 'perplexity') url = "https://api.perplexity.ai/chat/completions";

            let messages = [{ role: "system", content: prompt }].concat(chatHistory);
            let currentContent = text;
            if (fileBase64) currentContent = [{ type: "text", text: text }, { type: "image_url", image_url: { url: `data:${mimeType};base64,${fileBase64}` } }];
            messages.push({ role: "user", content: currentContent });
            body = { model: model, messages: messages, temperature: 0.7 };
        }

        const res = await fetch(url, { method: 'POST', headers: headers, body: JSON.stringify(body), signal: signal });
        if (!res.ok) throw new Error(`API éŒ¯èª¤ (${res.status}): ${await res.text()}`);
        const data = await res.json();
        
        if (provider === 'gemini') return data.candidates?.[0]?.content?.parts.map(p => p.text).join('') || "ç„¡å…§å®¹";
        else return data.choices?.[0]?.message.content || "ç„¡å…§å®¹";
    }
</script>
</body>
</html>
